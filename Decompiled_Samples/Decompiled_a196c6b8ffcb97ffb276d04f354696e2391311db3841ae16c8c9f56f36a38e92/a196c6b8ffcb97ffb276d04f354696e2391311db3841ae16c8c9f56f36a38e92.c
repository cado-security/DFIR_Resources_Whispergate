//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <locale.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int224_t;

// ------------------------ Structures ------------------------

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _IO_FILE {
    int32_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _MEMORY_BASIC_INFORMATION {
    int32_t * e0;
    int32_t * e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _WIN32_FIND_DATAA {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    char e8[1];
    char e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

// ------------------- Function Prototypes --------------------

void entry_point(int32_t at);
int32_t function_401000(int32_t a1);
int32_t function_4011b0(void);
int32_t function_4012a0(void);
int32_t function_401320(void (*func)());
int32_t (*function_401330(int32_t (*Function)()))();
int32_t function_401340(void);
int32_t function_401421(void);
int32_t function_401460(void);
int32_t function_401800(void);
int32_t function_401910(void);
int32_t function_401940(void);
int32_t function_401990(void);
int32_t function_4019b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401a00(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401a90(void);
int32_t function_401aa0(void);
int32_t function_401b00(int32_t a1, int32_t a2);
int32_t function_401b90(int32_t a1);
int32_t function_401c30(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401cd0(char * format, int32_t a2, int32_t a3);
int32_t function_401d20(int32_t a1);
int32_t function_401e10(void);
int32_t function_401fe0(void);
int32_t function_402010(int32_t a1);
int32_t function_402080(void);
int32_t function_402120(int32_t a1);
int32_t function_402190(void);
int32_t function_402450(void);
int32_t function_402670(void);
int32_t function_4026d0(void);
int32_t function_402720(int32_t a1);
int32_t function_402fb0(int32_t str, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4030a0(int32_t a1);
int32_t function_403100(int32_t result);
int32_t function_403500(void);
int32_t function_4035d0(void);
int32_t function_403680(int32_t a1);
int32_t function_403840(int32_t result);
int32_t function_403890(int32_t a1);
int32_t function_4038e0(int32_t a1);
int32_t function_403940(int32_t a1);
int32_t function_403970(int32_t a1, uint32_t a2);
int32_t function_4039f0(char * s, int16_t * pwcs, int32_t n);
int32_t function_4039f8(struct _IO_FILE * s, char * format, int32_t arg);
int32_t function_403a00(int32_t c);
int32_t function_403a08(char * s);
int32_t function_403a10(char * s1, char * s2);
void (*function_403a18(int32_t sig, void (*handler)(int32_t)))(int32_t);
char * function_403a20(int32_t category, char * locale);
int32_t * function_403a28(int32_t * ptr, int32_t size);
int32_t * function_403a30(int32_t * dest, int32_t * src, int32_t n);
int32_t function_403a38(int16_t * pwcs, char * s, int32_t n);
int32_t * function_403a40(int32_t size);
int32_t function_403a48(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
void function_403a50(int32_t * ptr);
int32_t * function_403a58(int32_t nmemb, int32_t size);
void function_403a60(void);
int32_t function_403a68(int32_t FileHandle, int32_t Mode);
int32_t function_403a70(int32_t C, int32_t Type);
char * function_403a78(char * Buffer, char * Path, int32_t BufferCount);
int32_t * function_403a80(void);
void function_403a88(void);
int32_t * function_403a90(void);
char *** function_403a98(void);
int32_t function_403aa0(int32_t * Argc, char *** Argv, char *** Env, int32_t DoWildCard, int32_t * StartInfo);
bool function_403aa8(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped);
int32_t function_403ab0(int32_t * lpAddress, struct _MEMORY_BASIC_INFORMATION * lpBuffer, int32_t dwLength);
bool function_403ab8(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect);
int32_t * function_403ac0(int32_t dwTlsIndex);
int32_t (*function_403ac8(int32_t (*lpTopLevelExceptionFilter)(struct _EXCEPTION_POINTERS *)))(struct _EXCEPTION_POINTERS *);
int32_t * function_403ad0(char * lpLibFileName);
void function_403ad8(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_403ae0(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
int32_t (*function_403ae8(int32_t * hModule, char * lpProcName))();
int32_t * function_403af0(char * lpModuleName);
int32_t function_403af8(void);
char * function_403b00(void);
bool function_403b08(int32_t * hLibModule);
bool function_403b10(int32_t * hFindFile, struct _WIN32_FIND_DATAA * lpFindFileData);
int32_t * function_403b18(char * lpFileName, struct _WIN32_FIND_DATAA * lpFindFileData);
bool function_403b20(int32_t * hFindFile);
void function_403b28(int32_t uExitCode);
void function_403b30(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_403b38(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
int32_t * function_403b40(int16_t * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile);
bool function_403b48(int32_t * hObject);
int32_t function_403b50(char * String1, char * String2);
char * function_403b58(char * Source);
int32_t function_403b60(int32_t a1);
int32_t function_403c20(void);

// --------------------- Global Variables ---------------------

int32_t g1 = -1; // 0x403c30
int32_t g2 = 0; // 0x404000
char * g3 = "\xeb"; // 0x404020
char g4 = 2; // 0x406020
int32_t g5 = -3; // 0x406024
int32_t g6 = 0x4000; // 0x406028
int32_t g7 = 0x403c40; // 0x40602c
int224_t * g8 = (int224_t *)-1; // 0x406030
int32_t g9 = 0; // 0x406034
char * g10 = "."; // 0x40713c
char * g11; // 0x407150
int32_t g12 = 46; // 0x407152
int32_t g13 = 20; // 0x4080b8
char *** g14 = NULL; // 0x409000
int32_t g15 = 0; // 0x409004
int32_t g16 = 0; // 0x409008
int32_t g17 = 0; // 0x409020
char g18 = 0; // 0x409024
int32_t g19 = 0; // 0x409028
int32_t g20 = 0; // 0x40903c
int32_t g21 = 0; // 0x409040
struct _RTL_CRITICAL_SECTION * g22 = NULL; // 0x409044
int32_t g23 = 0; // 0x40905c
int32_t g24 = 0; // 0x409064
int32_t g25 = 0; // 0x409068
int32_t g26 = 0; // 0x40906c
int32_t g27;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x4011a5
int32_t function_401000(int32_t a1) {
    uint32_t v1 = *(int32_t *)*(int32_t *)a1; // 0x401009
    if (v1 < 0xc0000092) {
        if (v1 >= 0xc000008d) {
            goto lab_0x401079;
        } else {
            if (v1 == -0x3ffffffb) {
                void (*prev_sig_handler)(int32_t) = signal(SIGSEGV, SIG_DFL); // 0x401033
                int32_t result; // 0x401000
                if (prev_sig_handler == (void (*)(int32_t))1) {
                    // 0x401189
                    signal(SIGSEGV, SIG_IGN);
                    result = -1;
                } else {
                    // 0x401041
                    result = prev_sig_handler != NULL;
                }
                // 0x401052
                return result;
            }
            // 0x4010f0
            if (v1 != -0x3fffffe3) {
                // 0x401052
                return 0;
            }
            goto lab_0x4010fb;
        }
    } else {
        switch (v1) {
            case -0x3fffff6c: {
                void (*prev_sig_handler2)(int32_t) = signal(SIGFPE, SIG_DFL); // 0x4010bf
                if (prev_sig_handler2 != (void (*)(int32_t))1) {
                    // 0x401096
                    return prev_sig_handler2 != NULL;
                }
                // 0x4010c9
                signal(SIGFPE, SIG_IGN);
                // 0x401052
                return -1;
            }
            case -0x3fffff6a: {
                goto lab_0x4010fb;
            }
            default: {
                // 0x401072
                if (v1 != -0x3fffff6d) {
                    // 0x401052
                    return 0;
                }
                goto lab_0x401079;
            }
        }
    }
  lab_0x401079:;
    void (*prev_sig_handler3)(int32_t) = signal(SIGFPE, SIG_DFL); // 0x401088
    if (prev_sig_handler3 != (void (*)(int32_t))1) {
        // 0x401096
        return prev_sig_handler3 != NULL;
    }
    // 0x401143
    signal(SIGFPE, SIG_IGN);
    function_402010(0);
    // 0x401052
    return -1;
  lab_0x4010fb:
    // 0x4010fb
    switch ((int32_t)v2) {
        case 1: {
            // 0x40116d
            signal(SIGILL, SIG_IGN);
            // 0x401052
            return -1;
        }
        case 0: {
            // 0x401052
            return 0;
        }
    }
    // 0x401052
    return -1;
}

// Address range: 0x4011b0 - 0x401297
int32_t function_4011b0(void) {
    // 0x4011b0
    function_401a00(0, 2, 0);
    int32_t v1 = 0x401000; // bp-40, 0x4011dc
    SetUnhandledExceptionFilter((int32_t (*)(struct _EXCEPTION_POINTERS *))&g27);
    int32_t v2 = (int32_t)&v1 - 4; // 0x4011e8
    function_401800();
    int32_t * v3 = (int32_t *)v2; // 0x4011f5
    *v3 = g5;
    function_402010((int32_t)&g27);
    function_401460();
    if (g17 != 0) {
        int32_t v4 = *(int32_t *)0x40a1b8; // 0x40120b
        g6 = g17;
        v1 = g17;
        *v3 = *(int32_t *)(v4 + 16);
        _setmode((int32_t)&g27, (int32_t)&g27);
        v1 = g17;
        *v3 = *(int32_t *)(v4 + 48);
        _setmode((int32_t)&g27, (int32_t)&g27);
        v1 = g17;
        *v3 = *(int32_t *)(v4 + 80);
        _setmode((int32_t)&g27, (int32_t)&g27);
    }
    // 0x40124d
    *__p__fmode() = g6;
    function_401e10();
    int32_t v5 = v2 & -16; // 0x40125f
    function_401990();
    *(int32_t *)(v5 | 8) = (int32_t)*__p__environ();
    *(int32_t *)(v5 | 4) = (int32_t)g14;
    int32_t * v6 = (int32_t *)v5; // 0x401280
    *v6 = g15;
    int32_t v7 = function_403b60((int32_t)&g27); // 0x401283
    _cexit();
    *v6 = v7;
    ExitProcess((int32_t)&g27);
    // UNREACHABLE
}

// Address range: 0x4012a0 - 0x4012df
int32_t function_4012a0(void) {
    int32_t v1 = 0; // bp-16, 0x4012b6
    int32_t v2; // bp-20, 0x4012a0
    int32_t result = __getmainargs(&g15, (char ***)&g14, (char ***)&v2, (int32_t)(g4 % 2), &v1); // 0x4012d6
    return result;
}

// Address range: 0x401300 - 0x401315
void entry_point(int32_t at) {
    // 0x401300
    __set_app_type(at);
    function_4011b0();
    // UNREACHABLE
}

// Address range: 0x401320 - 0x401326
int32_t function_401320(void (*func)()) {
    // 0x401320
    return atexit(func);
}

// Address range: 0x401330 - 0x401336
int32_t (*function_401330(int32_t (*Function)()))() {
    // 0x401330
    return _onexit(Function);
}

// Address range: 0x401340 - 0x401421
int32_t function_401340(void) {
    int32_t * moduleHandle = GetModuleHandleA("libgcc_s_dw2-1.dll"); // 0x40134f
    int32_t v1; // 0x401340
    char * v2; // bp-32, 0x401340
    if (moduleHandle == NULL) {
        // 0x4013a2
        g2 = 0;
        v1 = (int32_t)&v2;
    } else {
        // 0x4013a2
        v2 = "libgcc_s_dw2-1.dll";
        g26 = (int32_t)LoadLibraryA("libgcc_s_dw2-1.dll");
        v2 = "__register_frame_info";
        int32_t (*func)() = GetProcAddress(moduleHandle, "__register_frame_info"); // 0x401380
        int32_t (*func2)() = GetProcAddress(moduleHandle, "__deregister_frame_info"); // 0x401395
        int32_t v3; // bp-52, 0x401340
        int32_t v4 = &v3; // 0x40139a
        g2 = (int32_t)func2;
        v1 = v4;
        if (func != NULL) {
            // 0x4013a6
            *(int32_t *)(v4 + 4) = (int32_t)&g16;
            v3 = &g13;
            v1 = v4;
        }
    }
    // 0x4013b7
    if (g9 == 0) {
        // 0x4013fa
        *(int32_t *)v1 = 0x401430;
        return 0;
    }
    int32_t * v5 = (int32_t *)v1; // 0x4013c0
    *v5 = (int32_t)"libgcj-16.dll";
    int32_t * moduleHandle2 = GetModuleHandleA((char *)&g27); // 0x4013c7
    int32_t result = (int32_t)moduleHandle2; // 0x4013c7
    int32_t v6 = v1 - 4; // 0x4013cc
    if (moduleHandle2 == NULL) {
        // 0x4013fa
        *(int32_t *)v6 = 0x401430;
        return result;
    }
    // 0x4013ed
    *v5 = (int32_t)"_Jv_RegisterClasses";
    *(int32_t *)v6 = result;
    int32_t (*func3)() = GetProcAddress(&g27, (char *)&g27); // 0x4013e3
    int32_t v7 = v1 - 12; // 0x4013e8
    if (func3 != NULL) {
        // 0x4013f1
        *(int32_t *)v7 = (int32_t)&g9;
    }
    // 0x4013fa
    *(int32_t *)v7 = 0x401430;
    return (int32_t)func3;
}

// Address range: 0x401421 - 0x40145e
int32_t function_401421(void) {
    int32_t result = 0; // 0x40144f
    if (g26 != 0) {
        // 0x401451
        result = FreeLibrary((int32_t *)g26);
    }
    // 0x40145c
    return result;
}

// Address range: 0x401460 - 0x4017ff
int32_t function_401460(void) {
    // 0x401460
    if ((g4 & 2) == 0) {
        // 0x401760
        int32_t result; // 0x401460
        return result;
    }
    char * commandLine = GetCommandLineA(); // 0x401476
    char * v1 = commandLine; // bp-92, 0x40147e
    strlen(commandLine);
    int32_t v2 = (int32_t)&v1 - function_401fe0(); // 0x401497
    int32_t v3 = v2 + 16; // 0x4014a7
    int32_t v4 = (int32_t)g4 & 0x4400 | 16; // 0x4014c1
    char v5 = *commandLine; // 0x4014d3
    int32_t v6 = v4; // 0x4014db
    int32_t v7 = 0; // 0x4014db
    int32_t v8 = v3; // 0x4014db
    char v9; // 0x401460
    int32_t v10; // 0x401460
    int32_t v11; // 0x401460
    int32_t v12; // 0x401460
    int32_t v13; // 0x401460
    int32_t v14; // 0x401460
    int32_t v15; // 0x401460
    char v16; // 0x401460
    int32_t v17; // 0x401460
    char v18; // 0x401460
    int32_t v19; // 0x401460
    int32_t v20; // 0x401460
    int32_t v21; // 0x401460
    int32_t v22; // 0x401460
    int32_t v23; // 0x401460
    int32_t v24; // 0x401460
    int32_t v25; // 0x401460
    int32_t v26; // 0x401460
    int32_t v27; // bp-44, 0x401460
    int32_t v28; // 0x401460
    int32_t v29; // 0x401460
    int32_t v30; // 0x401460
    int32_t v31; // 0x401460
    int32_t v32; // 0x401460
    int32_t v33; // 0x401460
    int32_t v34; // 0x401460
    int32_t v35; // 0x401460
    int32_t v36; // 0x401460
    int32_t v37; // 0x401460
    int32_t v38; // 0x401460
    int32_t * v39; // 0x401460
    int32_t * v40; // 0x401460
    int32_t * v41; // 0x401460
    int32_t * v42; // 0x401460
    int32_t v43; // 0x401460
    if (v5 != 0) {
        // 0x4014dd
        v39 = (int32_t *)(v2 + 4);
        v40 = (int32_t *)v2;
        v41 = (int32_t *)(v2 + 8);
        v42 = (int32_t *)(v2 + 12);
        v43 = &v27;
        v9 = v5;
        v25 = (int32_t)commandLine;
        v20 = v3;
        v10 = 0;
        v36 = v4;
        v31 = 0;
        v28 = 0;
        while (true) {
          lab_0x4014dd_2:
            // 0x4014dd
            v37 = v36;
            int32_t v44 = v28; // 0x401460
            int32_t v45 = v31; // 0x401460
            int32_t v46 = v10; // 0x401460
            char v47 = v9; // 0x401460
            int32_t v48 = v20; // 0x401460
            int32_t v49 = v25; // 0x401460
            while (true) {
              lab_0x4014dd:
                // 0x4014dd
                v23 = v48;
                v16 = v47;
                v13 = v46;
                v34 = v45;
                v30 = v44;
                v26 = v49 + 1;
                if (v16 == 63) {
                    // break -> 0x401673
                    break;
                }
                if (v16 > 63) {
                    switch (v16) {
                        case 92: {
                            if (v30 == 39) {
                                // 0x401781
                                *(char *)v23 = 92;
                                v29 = 39;
                                v32 = v34;
                                v11 = v13;
                                v21 = v23 + 1;
                                goto lab_0x4014d0;
                            } else {
                                // 0x40169d
                                v29 = v30;
                                v32 = v34;
                                v11 = v13 + 1;
                                v21 = v23;
                                goto lab_0x4014d0;
                            }
                        }
                        case 127: {
                            goto lab_0x401673;
                        }
                        default: {
                            // 0x4015b2
                            v15 = v16;
                            if (v16 != 91) {
                                goto lab_0x401610_2;
                            } else {
                                // 0x4015b7
                                if ((g4 & 32) != 0) {
                                    goto lab_0x401673;
                                } else {
                                    // 0x4015c4
                                    v18 = 1;
                                    v24 = v23;
                                    if (v13 == 0) {
                                        goto lab_0x401602;
                                    } else {
                                        goto lab_0x4015d0;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (v16) {
                    case 39: {
                        // 0x4016a5
                        v15 = 39;
                        if ((g4 & 16) == 0) {
                            goto lab_0x401610_2;
                        } else {
                            int32_t v50 = v23; // 0x4016b6
                            if (v13 >= 2) {
                                int32_t v51 = v23 + v13 / 2; // 0x4016bc
                                int32_t v52 = v23 + 1; // 0x4016c0
                                *(char *)v23 = 92;
                                v50 = v51;
                                while (v52 != v51) {
                                    int32_t v53 = v52;
                                    v52 = v53 + 1;
                                    *(char *)v53 = 92;
                                    v50 = v51;
                                }
                            }
                            // 0x4016cb
                            v19 = v50;
                            if (v30 == 34) {
                                goto lab_0x40176d;
                            } else {
                                if (v13 % 2 != 0) {
                                    goto lab_0x40176d;
                                } else {
                                    // 0x4016dd
                                    v29 = v30 ^ 39;
                                    v32 = 1;
                                    v11 = 0;
                                    v21 = v19;
                                    goto lab_0x4014d0;
                                }
                            }
                        }
                    }
                    case 42: {
                        goto lab_0x401673;
                    }
                    default: {
                        if (v16 != 34) {
                            // 0x401610
                            v15 = v16;
                            goto lab_0x401610_2;
                        }
                        int32_t v54 = v23; // 0x40150b
                        if (v13 >= 2) {
                            int32_t v55 = v23 + v13 / 2; // 0x401511
                            int32_t v56 = v23 + 1; // 0x401513
                            *(char *)v23 = 92;
                            v54 = v55;
                            while (v56 != v55) {
                                int32_t v57 = v56;
                                v56 = v57 + 1;
                                *(char *)v57 = 92;
                                v54 = v55;
                            }
                        }
                        // 0x40151e
                        v17 = v54;
                        if (v30 == 39) {
                            goto lab_0x4016f1_2;
                        }
                        if (v13 % 2 != 0) {
                            goto lab_0x4016f1_2;
                        }
                        char v58 = *(char *)v26; // 0x401539
                        v44 = v30 ^ 34;
                        v45 = 1;
                        v46 = 0;
                        v47 = v58;
                        v48 = v17;
                        v49 = v26;
                        v35 = v37;
                        v14 = v17;
                        if (v58 == 0) {
                            goto lab_0x401732;
                        }
                        goto lab_0x4014dd;
                    }
                }
            }
            goto lab_0x401673;
        }
      lab_0x401550:
        // 0x401550
        v6 = v38;
        v7 = v33;
        v8 = v22;
        if (v12 != 0) {
            int32_t v59 = v22 + v12; // 0x401558
            int32_t v60 = v22 + 1; // 0x401560
            *(char *)v22 = 92;
            v6 = v38;
            v7 = v33;
            v8 = v59;
            while (v60 != v59) {
                int32_t v61 = v60;
                v60 = v61 + 1;
                *(char *)v61 = 92;
                v6 = v38;
                v7 = v33;
                v8 = v59;
            }
        }
    }
    // 0x40156b
    int32_t result2; // 0x401460
    if (v7 == 0 && v8 <= v3) {
        // 0x40157f
        g14 = (char ***)result2;
        return result2;
    }
    // 0x40156b
    v40 = (int32_t *)v2;
    v39 = (int32_t *)(v2 + 4);
    v43 = &v27;
    v42 = (int32_t *)(v2 + 12);
    v41 = (int32_t *)(v2 + 8);
    v35 = v6;
    v14 = v8;
  lab_0x401732:
    // 0x401732
    *(char *)v14 = 0;
    *v41 = 0;
    *v42 = v43;
    *v39 = v35;
    *v40 = v3;
    function_402fb0((int32_t)&g27, (int32_t)&g27, (int32_t)&g27, (int32_t)&g27);
    // 0x40157f
    g14 = (char ***)result2;
    return result2;
  lab_0x4016f1_2:
    // 0x4016f1
    *(char *)v17 = 34;
    v29 = v30;
    v32 = 1;
    v11 = 0;
    v21 = v17 + 1;
    goto lab_0x4014d0;
  lab_0x401673:;
    int32_t v70; // 0x401460
    char v71; // 0x401460
    if (v13 == 0) {
        // 0x4017cc
        v70 = v23;
        v71 = v30 != 0 | v16 == 127;
        goto lab_0x4015eb;
    } else {
        // 0x40167e
        v18 = v30 != 0 | v16 == 127;
        goto lab_0x4015d0;
    }
  lab_0x4015eb:;
    int32_t v72 = v70; // 0x4015ed
    v24 = v70;
    if (v71 != 0) {
        goto lab_0x401602;
    } else {
        goto lab_0x4015ef;
    }
  lab_0x4015d0:;
    int32_t v73 = v23 + 1; // 0x4015e0
    *(char *)v23 = 92;
    int32_t v74 = v73; // 0x4015e9
    v70 = v73;
    v71 = v18;
    while (v73 != v23 + v13) {
        // 0x4015e0
        v73 = v74 + 1;
        *(char *)v74 = 92;
        v74 = v73;
        v70 = v73;
        v71 = v18;
    }
    goto lab_0x4015eb;
  lab_0x401602:
    // 0x401602
    *(char *)v24 = 127;
    v72 = v24 + 1;
    goto lab_0x4015ef;
  lab_0x4015ef:
    // 0x4015ef
    *(char *)v72 = v16;
    v29 = v30;
    v32 = v34;
    v11 = 0;
    v21 = v72 + 1;
    goto lab_0x4014d0;
  lab_0x4014d0:
    // 0x4014d0
    v22 = v21;
    v12 = v11;
    v38 = v37;
    v33 = v32;
    char v62 = *(char *)v26; // 0x4014d3
    v9 = v62;
    v25 = v26;
    v20 = v22;
    v10 = v12;
    v36 = v38;
    v31 = v33;
    v28 = v29;
    if (v62 == 0) {
        // break -> 0x401550
        goto lab_0x401550;
    }
    goto lab_0x4014dd_2;
  lab_0x401610_2:;
    int32_t v63 = v15;
    int32_t v64 = v23 + v13; // 0x401612
    int32_t v65 = v23; // 0x401615
    int32_t v66 = v23; // 0x401615
    if (v13 != 0) {
        int32_t v67 = v65 + 1; // 0x401620
        *(char *)v65 = 92;
        v65 = v67;
        v66 = v64;
        while (v67 != v64) {
            // 0x401620
            v67 = v65 + 1;
            *(char *)v65 = 92;
            v65 = v67;
            v66 = v64;
        }
    }
    int32_t v68 = v66;
    if (v30 != 0) {
        goto lab_0x401667;
    } else {
        // 0x401632
        if (*(int32_t *)*(int32_t *)0x40a198 == 1) {
            int32_t v69 = *(int32_t *)*(int32_t *)0x40a1c4; // 0x40170a
            if (v16 == 9 | (*(char *)(v69 + 2 * v63) & 64) != 0) {
                goto lab_0x401716;
            } else {
                goto lab_0x401667;
            }
        } else {
            // 0x401640
            *v39 = 64;
            *v40 = v63;
            if (v16 == 9 | _isctype(v63, (int32_t)&g27) != 0) {
                goto lab_0x401716;
            } else {
                goto lab_0x401667;
            }
        }
    }
  lab_0x401667:
    // 0x401667
    *(char *)v68 = v16;
    v29 = v30;
    v32 = v34;
    v11 = 0;
    v21 = v68 + 1;
    goto lab_0x4014d0;
  lab_0x401716:
    // 0x401716
    v29 = v30;
    v32 = 0;
    v11 = 0;
    v21 = v68;
    if (v34 != 0 || v68 > v3) {
        // 0x401790
        *(char *)v68 = 0;
        *v41 = 0;
        *v42 = v43;
        *v39 = v37;
        *v40 = v3;
        function_402fb0((int32_t)&g27, (int32_t)&g27, (int32_t)&g27, (int32_t)&g27);
        v29 = v30;
        v32 = 0;
        v11 = 0;
        v21 = v3;
    }
    goto lab_0x4014d0;
  lab_0x40176d:
    // 0x40176d
    *(char *)v19 = 39;
    v29 = v30;
    v32 = 1;
    v11 = 0;
    v21 = v19 + 1;
    goto lab_0x4014d0;
}

// Address range: 0x401800 - 0x401907
int32_t function_401800(void) {
    // 0x401800
    return 0;
}

// Address range: 0x401910 - 0x40193c
int32_t function_401910(void) {
    // 0x401910
    if (*(int32_t *)g7 == 0) {
        // 0x40193a
        return 0;
    }
    int32_t v1 = g7; // 0x401919
    v1 += 4;
    int32_t result = *(int32_t *)v1; // 0x40192a
    g7 = v1;
    while (result != 0) {
        // 0x401920
        v1 += 4;
        result = *(int32_t *)v1;
        g7 = v1;
    }
    // 0x40193a
    return result;
}

// Address range: 0x401940 - 0x401986
int32_t function_401940(void) {
    int32_t v1 = 0;
    int32_t result = v1 + 1; // 0x401976
    while (*(int32_t *)(4 * result + (int32_t)&g1) != 0) {
        // 0x401976
        v1 = result;
        result = v1 + 1;
    }
    // 0x401984
    if (v1 == 0) {
        // 0x40195f
        return result;
    }
    int32_t v2 = v1; // 0x401951
    while (v2 != 1) {
        // 0x401953
        v2--;
    }
    // 0x40195f
    return result;
}

// Address range: 0x401990 - 0x4019ac
int32_t function_401990(void) {
    int32_t result = g19; // 0x401990
    if (result != 0) {
        // 0x401999
        return result;
    }
    // 0x4019a0
    g19 = 1;
    return function_401940();
}

// Address range: 0x4019b0 - 0x4019f3
int32_t function_4019b0(int32_t a1, int32_t a2, int32_t a3) {
    switch (a2) {
        case 3: {
        }
        case 0: {
            // 0x4019d0
            function_401c30(a1, a2, a3);
            return 1;
        }
    }
    // 0x4019c0
    return 1;
}

// Address range: 0x401a00 - 0x401a83
int32_t function_401a00(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401a00
    if (g24 != 2) {
        // 0x401a12
        g24 = 2;
    }
    if (a2 == 1) {
        // 0x401a65
        function_401c30(a1, 1, a3);
    }
    // 0x401a26
    return 1;
}

// Address range: 0x401a90 - 0x401a93
int32_t function_401a90(void) {
    // 0x401a90
    return 0;
}

// Address range: 0x401aa0 - 0x401b00
int32_t function_401aa0(void) {
    // 0x401aa0
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
    int32_t v1; // bp-32, 0x401aa0
    int32_t v2 = &v1; // 0x401ab7
    int32_t v3 = g20; // 0x401abc
    int32_t v4 = v2; // 0x401abc
    if (g20 == 0) {
        // 0x401aeb
        *(int32_t *)v2 = (int32_t)&g22;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g27);
        return &g27;
    }
    *(int32_t *)v4 = *(int32_t *)v3;
    int32_t * v5 = TlsGetValue((int32_t)&g27); // 0x401ac5
    v4 -= 4;
    if (!((v5 == NULL | GetLastError() != 0))) {
        // 0x401adc
        *(int32_t *)v4 = (int32_t)v5;
    }
    // 0x401ae4
    v3 += 8;
    while (v3 != 0) {
        // 0x401ac0
        *(int32_t *)v4 = *(int32_t *)v3;
        v5 = TlsGetValue((int32_t)&g27);
        v4 -= 4;
        if (!((v5 == NULL | GetLastError() != 0))) {
            // 0x401adc
            *(int32_t *)v4 = (int32_t)v5;
        }
        // 0x401ae4
        v3 += 8;
    }
    // 0x401aeb
    *(int32_t *)v4 = (int32_t)&g22;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g27);
    return &g27;
}

// Address range: 0x401b00 - 0x401b82
int32_t function_401b00(int32_t a1, int32_t a2) {
    // 0x401b00
    if (g21 == 0) {
        // 0x401b10
        return 0;
    }
    int32_t * mem = calloc(1, 12); // 0x401b2f
    if (mem == NULL) {
        // 0x401b10
        return -1;
    }
    int32_t v1 = (int32_t)mem; // 0x401b2f
    *mem = a1;
    *(int32_t *)(v1 + 4) = a2;
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
    int32_t v2 = g20; // 0x401b53
    g20 = v1;
    *(int32_t *)(v1 + 8) = v2;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
    return 0;
}

// Address range: 0x401b90 - 0x401c2b
int32_t function_401b90(int32_t a1) {
    // 0x401b90
    if (g21 == 0) {
        // 0x401ba1
        return 0;
    }
    // 0x401bb0
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
    if (g20 == 0) {
        // 0x401be0
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
        // 0x401ba1
        return 0;
    }
    int32_t * v1 = (int32_t *)g20;
    int32_t v2 = g20; // 0x401bcd
    int32_t * v3; // 0x401b90
    if (*v1 == a1) {
        // 0x401c1f
        g20 += 8;
        v3 = v1;
      lab_0x401c06:
        // 0x401c06
        free(v3);
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
        // 0x401ba1
        return 0;
    }
    int32_t * v4 = (int32_t *)(v2 + 8);
    v2 = *v4;
    while (v2 != 0) {
        // 0x401bd1
        v3 = (int32_t *)v2;
        if (*v3 == a1) {
            // 0x401c00
            *v4 = *(int32_t *)(v2 + 8);
            goto lab_0x401c06;
        }
        v4 = (int32_t *)(v2 + 8);
        v2 = *v4;
    }
    // 0x401be0
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
    // 0x401ba1
    return 0;
}

// Address range: 0x401c30 - 0x401cc7
int32_t function_401c30(int32_t a1, int32_t a2, int32_t a3) {
    switch (a1) {
        case 1: {
            // 0x401c83
            if (g21 == 0) {
                // 0x401ca0
                InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
            }
            // 0x401c8c
            g21 = 1;
            return 1;
        }
        case 0: {
            // 0x401c55
            if (g21 != 0) {
                // 0x401cc0
                function_401aa0();
            }
            // 0x401c5e
            if (g21 == 1) {
                // 0x401c68
                g21 = 0;
                DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g22);
            }
            // break -> 0x401c4c
            break;
        }
        default: {
            if (a1 != 3) {
                // 0x401c4c
                return 1;
            }
            // 0x401c43
            if (g21 != 0) {
                // 0x401cb1
                function_401aa0();
            }
            // break -> 0x401c4c
            break;
        }
    }
    // 0x401c4c
    return 1;
}

// Address range: 0x401cd0 - 0x401d1a
int32_t function_401cd0(char * format, int32_t a2, int32_t a3) {
    struct _IO_FILE * stream = (struct _IO_FILE *)(*(int32_t *)0x40a1b8 + 64); // 0x401cfc
    fwrite((int32_t *)"Mingw runtime failure:\n", 1, 23, stream);
    int32_t v1; // 0x401cd0
    vfprintf(stream, format, (int32_t)&v1);
    abort();
    // UNREACHABLE
}

// Address range: 0x401d20 - 0x401e10
int32_t function_401d20(int32_t a1) {
    // 0x401d20
    int32_t v1; // 0x401d20
    int32_t * lpAddress = (int32_t *)v1; // 0x401d40
    int32_t lpBuffer; // bp-56, 0x401d20
    if (VirtualQuery(lpAddress, (struct _MEMORY_BASIC_INFORMATION *)&lpBuffer, 28) == 0) {
        // 0x401df8
        return function_401cd0("  VirtualQuery failed for %d bytes at address %p", 28, v1);
    }
    int32_t v2; // 0x401d20
    int32_t v3; // 0x401d20
    int32_t v4; // 0x401d20
    if (v4 != 64 != v4 != 4) {
        // 0x401d6e
        return (int32_t)memcpy(lpAddress, (int32_t *)v2, v3);
    }
    // 0x401d80
    int32_t lpflOldProtect; // bp-72, 0x401d20
    int32_t lpAddress2; // 0x401d20
    VirtualProtect((int32_t *)lpAddress2, lpBuffer, 64, &lpflOldProtect);
    int32_t * dest_mem = memcpy(lpAddress, (int32_t *)v2, v3); // 0x401dba
    int32_t v5; // 0x401d20
    switch (v5) {
        case 64: {
        }
        case 4: {
            // 0x401d6e
            return (int32_t)dest_mem;
        }
    }
    bool result = VirtualProtect((int32_t *)28, lpflOldProtect, (int32_t)&lpBuffer, &lpflOldProtect); // 0x401de8
    return result;
}

// Address range: 0x401e10 - 0x401fdb
int32_t function_401e10(void) {
    int32_t result = g23; // 0x401e10
    if (result == 0) {
        // 0x401e20
        g23 = 1;
    }
    // 0x401e19
    return result;
}

// Address range: 0x401fe0 - 0x40200a
int32_t function_401fe0(void) {
    // 0x401fe0
    int32_t result; // 0x401fe0
    return result;
}

// Address range: 0x402010 - 0x40207c
int32_t function_402010(int32_t a1) {
    int32_t v1 = a1; // 0x402010
    int32_t v2; // 0x402010
    switch (a1) {
        case -3: {
            // 0x402055
            g8 = (int224_t *)-1;
            v2 = 0x1f80;
            goto lab_0x402041;
        }
        case -4: {
            // 0x402063
            g8 = (int224_t *)-2;
            // 0x40206d
            _fpreset();
            v2 = 0x1f80;
            goto lab_0x402041;
        }
        case 0: {
            // 0x402075
            v1 = (int32_t)g8;
            goto lab_0x40202d;
        }
        default: {
            goto lab_0x40202d;
        }
    }
  lab_0x40202d:
    // 0x40202d
    v2 = 0x1f80;
    switch (v1) {
        case -1: {
            goto lab_0x402041;
        }
        case -2: {
            // 0x40206d
            _fpreset();
            v2 = 0x1f80;
            goto lab_0x402041;
        }
        default: {
            // 0x402037
            __asm_fldenv(*(int224_t *)v1);
            v2 = (int32_t)*(int16_t *)(v1 + 28);
            goto lab_0x402041;
        }
    }
  lab_0x402041:
    // 0x402041
    if ((g18 & 16) != 0) {
        // 0x40204a
        __asm_ldmxcsr(v2);
    }
    // 0x40204f
    return 0;
}

// Address range: 0x402080 - 0x402113
int32_t function_402080(void) {
    // 0x402080
    int32_t v1; // 0x402080
    if (v1 == 0) {
        // 0x4020d0
        return 0;
    }
    char v2 = *(char *)v1; // 0x4020a0
    int32_t result = 0; // 0x4020a5
    if (v2 == 0) {
      lab_0x4020d0_2:
        // 0x4020d0
        return result;
    }
    char v3 = v2; // 0x4020a0
    int32_t v4; // 0x402080
    int32_t v5 = v4; // 0x402080
    int32_t v6 = 0; // 0x402080
    int32_t v7 = v3; // 0x402080
    int32_t v8; // 0x402080
    int32_t v9; // 0x402080
    int32_t v10; // 0x402080
    int32_t v11; // 0x402080
    int32_t v12; // 0x402080
    int32_t v13; // 0x402080
    int32_t v14; // 0x402080
    char v15; // 0x4020c6
    int32_t v16; // 0x4020c6
    while (true) {
        // 0x4020a7
        v10 = v7;
        v9 = v6;
        v8 = v5;
        v14 = v8 + 1;
        v11 = v14;
        if ((v13 & 32) == 0 == v10 == 127) {
            // 0x4020f0
            result = 0;
            if (*(char *)v14 == 0) {
                return result;
            }
            // 0x4020f9
            v11 = v8 + 2;
        }
        // 0x4020b3
        v12 = v11;
        if (v9 != 0) {
            // break -> 0x4020d5
            break;
        }
        // 0x4020b7
        result = 1;
        switch (v10) {
            case 63: {
                return result;
            }
            case 42: {
                return result;
            }
            default: {
                // 0x4020c1
                v15 = *(char *)v12;
                v16 = v15;
                v5 = v12;
                v6 = v10 == 91;
                v7 = v16;
                result = v16;
                if (v15 == 0) {
                    return result;
                }
                goto lab_0x4020a7;
            }
        }
    }
    // 0x4020d5
    result = 1;
    while (v9 > 1 != (v10 == 93)) {
        // 0x4020df
        v3 = *(char *)v12;
        result = 0;
        if (v3 == 0) {
            // break -> 0x4020d0
            break;
        }
        v5 = v12;
        v6 = v9 + (int32_t)(v10 != 33);
        v7 = v3;
        while (true) {
            // 0x4020a7
            v10 = v7;
            v9 = v6;
            v8 = v5;
            v14 = v8 + 1;
            v11 = v14;
            if ((v13 & 32) == 0 == v10 == 127) {
                // 0x4020f0
                result = 0;
                if (*(char *)v14 == 0) {
                    return result;
                }
                // 0x4020f9
                v11 = v8 + 2;
            }
            // 0x4020b3
            v12 = v11;
            if (v9 != 0) {
                // break -> 0x4020d5
                break;
            }
            // 0x4020b7
            result = 1;
            switch (v10) {
                case 63: {
                    return result;
                }
                case 42: {
                    return result;
                }
                default: {
                    // 0x4020c1
                    v15 = *(char *)v12;
                    v16 = v15;
                    v5 = v12;
                    v6 = v10 == 91;
                    v7 = v16;
                    result = v16;
                    if (v15 == 0) {
                        return result;
                    }
                    goto lab_0x4020a7;
                }
            }
        }
        // 0x4020d5
        result = 1;
    }
    // 0x4020d0
    return result;
}

// Address range: 0x402120 - 0x402183
int32_t function_402120(int32_t a1) {
    // 0x402120
    int32_t v1; // 0x402120
    if (v1 == 0) {
        // 0x402170
        return 0;
    }
    int32_t v2 = *(int32_t *)(v1 + 12) + 1; // 0x40212e
    int32_t * mem = malloc(4 * v2); // 0x40213b
    int32_t v3 = (int32_t)mem; // 0x40213b
    *(int32_t *)(v1 + 8) = v3;
    if (mem == NULL) {
        // 0x402170
        return 3;
    }
    // 0x40214e
    *(int32_t *)(v1 + 4) = 0;
    if (v2 < 1) {
        // 0x402170
        return 0;
    }
    int32_t v4 = v2; // 0x402159
    v4--;
    *(int32_t *)(4 * v4 + v3) = 0;
    while (v4 != 0) {
        // 0x402160
        v4--;
        *(int32_t *)(4 * v4 + v3) = 0;
    }
    // 0x402170
    return 0;
}

// Address range: 0x402190 - 0x402445
int32_t function_402190(void) {
    // 0x402190
    int32_t v1; // 0x402190
    int32_t v2 = 0x1000000 * v1 / 0x1000000; // 0x402199
    int32_t v3 = v2; // 0x402190
    char v4; // 0x402190
    int32_t v5; // 0x402190
    int32_t v6; // 0x402190
    int32_t v7; // 0x402190
    int32_t v8; // 0x402190
    int32_t c2; // 0x402190
    int32_t v9; // 0x402190
    switch ((char)v1) {
        case 93: {
        }
        case 45: {
            int32_t v10 = v1 + 1;
            if (c2 == v2) {
                // 0x402365
                v6 = v10;
                while (true) {
                  lab_0x402370_2:;
                    int32_t v11 = v6;
                    char v12 = *(char *)v11; // 0x402370
                    v4 = v12;
                    v7 = v11;
                    v8 = v11;
                    switch (v12) {
                        case 93: {
                            return v8 + 1;
                        }
                        case 127: {
                            int32_t v13 = v11 + 1;
                            int32_t v14 = v13; // 0x402392
                            if ((v9 & 32) != 0) {
                                // 0x402370
                                v6 = v14;
                                goto lab_0x402370_2;
                            } else {
                                // 0x402394
                                v4 = *(char *)v13;
                                v7 = v13;
                                goto lab_0x40237b;
                            }
                        }
                        default: {
                            goto lab_0x40237b;
                        }
                    }
                }
              lab_0x4023a5:
                // 0x4023a5
                return v8 + 1;
            }
            // 0x402316
            v3 = (int32_t)*(char *)v10;
            v5 = v10;
            // break -> 0x4021b8
            break;
        }
    }
    int32_t v15 = v3; // 0x4021cf
    int32_t v16 = v2; // 0x4021cf
    int32_t v17 = v5; // 0x4021cf
    int32_t v18; // 0x402190
    int32_t v19; // 0x402190
    char v20; // 0x402190
    int32_t v21; // 0x402190
    int32_t v22; // 0x402190
    int32_t v23; // 0x402190
    int32_t v24; // 0x402190
    while (true) {
      lab_0x4021de:;
        int32_t v25 = v17;
        int32_t v26 = v25 + 1; // 0x4021e1
        v19 = v15;
        v21 = v26;
        switch (v15) {
            case 93: {
                return 0;
            }
            case 45: {
                char v27 = *(char *)v26; // 0x402280
                v20 = 93;
                v18 = 45;
                v24 = v26;
                if (v27 == 93) {
                    goto lab_0x402214;
                } else {
                    if (v27 == 0) {
                        // break -> 0x402304
                        break;
                    }
                    int32_t v28 = v16;
                    int32_t v29 = v27; // 0x40228d
                    int32_t v30 = v25 + 2; // 0x402298
                    int32_t v31 = v28; // 0x4022a3
                    if (v28 < v29) {
                        int32_t c = v31;
                        if ((v9 & 0x4000) != 0) {
                            if (c2 == c) {
                                // 0x4022e7
                                v22 = 0x1000000 * v30 / 0x1000000;
                                goto lab_0x4022f2;
                            }
                        } else {
                            // 0x4022cb
                            if (tolower(c) == tolower(c2)) {
                                // 0x4022e7
                                v22 = 0x1000000 * v30 / 0x1000000;
                                goto lab_0x4022f2;
                            }
                        }
                        int32_t v32 = c + 1; // 0x4022c6
                        while (v32 != v29) {
                            // 0x4022c4
                            c = v32;
                            if ((v9 & 0x4000) != 0) {
                                if (c2 == c) {
                                    // 0x4022e7
                                    v22 = 0x1000000 * v30 / 0x1000000;
                                    goto lab_0x4022f2;
                                }
                            } else {
                                // 0x4022cb
                                if (tolower(c) == tolower(c2)) {
                                    // 0x4022e7
                                    v22 = 0x1000000 * v30 / 0x1000000;
                                    goto lab_0x4022f2;
                                }
                            }
                            // 0x4022be
                            v32 = c + 1;
                        }
                        // 0x402330
                        v19 = v29;
                        v21 = 0x1000000 * v30 / 0x1000000;
                        goto lab_0x4021fb;
                    } else {
                        // 0x4023b8
                        v19 = v29;
                        v21 = v30;
                        int32_t v33 = v28; // 0x4023b8
                        if (v28 > v29) {
                            int32_t c3 = v33;
                            if ((v9 & 0x4000) != 0) {
                                if (c3 == c2) {
                                    // 0x402408
                                    v23 = 0x1000000 * v30 / 0x1000000;
                                    goto lab_0x402413;
                                }
                            } else {
                                // 0x4023ec
                                if (tolower(c3) == tolower(c2)) {
                                    // 0x402408
                                    v23 = 0x1000000 * v30 / 0x1000000;
                                    goto lab_0x402413;
                                }
                            }
                            int32_t v34 = c3 - 1; // 0x4023e7
                            while (v34 != v29) {
                                // 0x4023e5
                                c3 = v34;
                                if ((v9 & 0x4000) != 0) {
                                    if (c3 == c2) {
                                        // 0x402408
                                        v23 = 0x1000000 * v30 / 0x1000000;
                                        goto lab_0x402413;
                                    }
                                } else {
                                    // 0x4023ec
                                    if (tolower(c3) == tolower(c2)) {
                                        // 0x402408
                                        v23 = 0x1000000 * v30 / 0x1000000;
                                        goto lab_0x402413;
                                    }
                                }
                                // 0x4023db
                                v34 = c3 - 1;
                            }
                            // 0x402330
                            v19 = v29;
                            v21 = 0x1000000 * v30 / 0x1000000;
                            goto lab_0x4021fb;
                        } else {
                            goto lab_0x4021fb;
                        }
                    }
                }
            }
            case 0: {
                return 0;
            }
            default: {
                goto lab_0x4021fb;
            }
        }
    }
  lab_0x402304:
    // 0x402304
    return 0;
  lab_0x402243_2:
    // 0x402243
    v8 = v17;
    int32_t v35; // 0x402190
    char v36; // 0x402190
    char v37; // 0x402190
    if (v36 == 93) {
        return v8 + 1;
    } else {
        // 0x402267
        v35 = v17;
        v37 = v36;
        goto lab_0x402267_2;
    }
  lab_0x4021fb:
    // 0x4021fb
    switch (v19) {
        case 92: {
            return 0;
        }
        case 47: {
            return 0;
        }
        default: {
            // 0x40220d
            v20 = *(char *)v21;
            v18 = v19;
            v24 = v21;
            goto lab_0x402214;
        }
    }
  lab_0x402214:
    // 0x402214
    v17 = v24;
    int32_t c4 = v18;
    v36 = v20;
    if ((v9 & 0x4000) != 0) {
        if (c4 == c2) {
            goto lab_0x402243_2;
        }
    } else {
        // 0x40221e
        if (tolower(c4) == tolower(c2)) {
            goto lab_0x402243_2;
        }
    }
    // 0x4021db
    v15 = v36;
    v16 = c4;
    goto lab_0x4021de;
  lab_0x40237b:
    // 0x40237b
    if (v4 == 0) {
        // 0x402304
        return 0;
    }
    // 0x402370
    v6 = v7 + 1;
    goto lab_0x402370_2;
  lab_0x402267_2:;
    int32_t v38 = v35;
    char v39 = v37; // 0x40226a
    int32_t v40 = v38; // 0x40226a
    int32_t v41; // 0x402190
    if (v37 != 127) {
        goto lab_0x402250;
    } else {
        int32_t v42 = v38 + 1;
        v41 = v42;
        if ((v9 & 32) != 0) {
            goto lab_0x40225b;
        } else {
            // 0x402274
            v39 = *(char *)v42;
            v40 = v42;
            goto lab_0x402250;
        }
    }
  lab_0x402250:
    // 0x402250
    v41 = v40 + 1;
    if (v39 == 0) {
        goto lab_0x402304;
    } else {
        goto lab_0x40225b;
    }
  lab_0x40225b:;
    char v43 = *(char *)v41; // 0x40225b
    v35 = v41;
    v37 = v43;
    v8 = v41;
    if (v43 == 93) {
        goto lab_0x4023a5;
    } else {
        goto lab_0x402267_2;
    }
  lab_0x4022f2:;
    char v44 = *(char *)v22; // 0x4022f2
    char v45 = v44; // 0x4022f7
    int32_t v46 = v22; // 0x4022f7
    int32_t v47 = v22; // 0x4022f7
    if (v44 == 93) {
        // 0x40235a
        return v47 + 1;
    }
    goto lab_0x4022f9;
  lab_0x4022f9:;
    int32_t v48 = v46;
    char v49 = v45; // 0x4022fb
    int32_t v50 = v48; // 0x4022fb
    if (v45 == 127) {
        int32_t v51 = v48 + 1;
        char v52 = *(char *)v51;
        v49 = v52;
        v50 = v51;
        if ((v9 & 32) != 0) {
            // 0x402350
            v45 = v52;
            v46 = v51;
            v47 = v51;
            if (v52 == 93) {
                // 0x40235a
                return v47 + 1;
            }
            goto lab_0x4022f9;
        } else {
            goto lab_0x4022fd;
        }
    } else {
        goto lab_0x4022fd;
    }
  lab_0x4022fd:
    // 0x4022fd
    v22 = v50 + 1;
    if (v49 != 0) {
        goto lab_0x4022f2;
    } else {
        goto lab_0x402304;
    }
  lab_0x402413:;
    int32_t v53 = v23;
    char v54 = *(char *)v53; // 0x402413
    v47 = v53;
    char v55 = v54; // 0x402190
    int32_t v56 = v53; // 0x402190
    switch (v54) {
        case 93: {
            // 0x40235a
            return v47 + 1;
        }
        case 127: {
            int32_t v57 = v53 + 1;
            int32_t v58 = v57; // 0x402432
            if ((v9 & 32) != 0) {
                // 0x402413
                v23 = v58;
                goto lab_0x402413;
            } else {
                // 0x402434
                v55 = *(char *)v57;
                v56 = v57;
                goto lab_0x402422;
            }
        }
        default: {
            goto lab_0x402422;
        }
    }
  lab_0x402422:
    // 0x402422
    if (v55 != 0) {
        // 0x402413
        v23 = v56 + 1;
        goto lab_0x402413;
    } else {
        goto lab_0x402304;
    }
}

// Address range: 0x402450 - 0x40266a
int32_t function_402450(void) {
    // 0x402450
    int32_t v1; // 0x402450
    char v2 = v1;
    int32_t v3; // 0x402450
    int32_t v4; // 0x402450
    if ((char)v3 == 46 && v2 != 46) {
        // 0x4025a9
        if ((v4 & 0x10000) == 0) {
            // 0x4024f6
            return 0x1000000 * v1 / 0x1000000 - 46;
        }
    }
    char v5 = v2; // 0x402476
    char v6; // 0x402450
    int32_t v7; // 0x402450
    int32_t v8; // 0x402450
    int32_t result; // 0x402450
    int32_t v9; // 0x402450
    int32_t v10; // 0x402450
    int32_t v11; // 0x402450
    int32_t v12; // 0x402450
    int32_t v13; // 0x402450
    int32_t v14; // 0x402450
    int32_t v15; // 0x402450
    int32_t v16; // 0x402450
    int32_t v17; // 0x402450
    int32_t v18; // 0x402480
    while (true) {
      lab_0x40247a:
        // 0x40247a
        v17 = v16;
        int32_t v19 = v9;
        char v20 = v5;
        v18 = v19 + 1;
        switch (v20) {
            case 0: {
                return -(int32_t)*(char *)v17;
            }
            case 63: {
                // 0x402581
                v12 = v18;
                if (*(char *)v17 == 0) {
                    // 0x4024f6
                    return 63;
                }
                goto lab_0x402575;
            }
            case 91: {
                // 0x402550
                if (*(char *)v17 == 0) {
                    // 0x4024f6
                    return 91;
                }
                // 0x40255c
                if (*(char *)v18 == 33) {
                    int32_t v21 = v19 + 2; // 0x4025c2
                    v11 = v21;
                    if (function_402190() == 0) {
                        // 0x4025fe
                        if (*(char *)v21 == 93) {
                            int32_t v22 = v19 + 3; // 0x402661
                            char v23 = *(char *)v22; // 0x402664
                            v13 = v22;
                            v6 = v23;
                            v14 = v22;
                            if (v23 == 93) {
                                // 0x402634
                                v15 = v14;
                                v11 = v15 + 1;
                                goto lab_0x40256d;
                            } else {
                                goto lab_0x40261e_2;
                            }
                        } else {
                            goto lab_0x40261e_2;
                        }
                    } else {
                        goto lab_0x40256d;
                    }
                } else {
                    // 0x402562
                    v11 = function_402190();
                    goto lab_0x40256d;
                }
            }
            case 42: {
                char v24 = *(char *)v18; // 0x402500
                char v25 = v24; // 0x402509
                if (v24 == 42) {
                    int32_t v26 = v18 + 1; // 0x402510
                    char v27 = *(char *)v26; // 0x402513
                    int32_t v28 = v26; // 0x402519
                    v25 = v27;
                    while (v27 == 42) {
                        // 0x402510
                        v26 = v28 + 1;
                        v27 = *(char *)v26;
                        v28 = v26;
                        v25 = v27;
                    }
                }
                // 0x40251b
                if (v25 == 0) {
                    // 0x4024f6
                    return 0;
                }
                int32_t v29 = v17; // 0x40251f
                int32_t v30 = function_402450(); // 0x40253f
                result = v30;
                while (v30 != 0) {
                    int32_t v31 = v29;
                    result = v30;
                    v29 = v31 + 1;
                    if (*(char *)v31 == 0) {
                        // break -> 0x4024f6
                        break;
                    }
                    v30 = function_402450();
                    result = v30;
                }
              lab_0x4024f6:
                // 0x4024f6
                return result;
            }
            default: {
                // 0x4024a2
                v7 = v20;
                if ((v4 & 32) == 0 == v20 == 127) {
                    char v32 = *(char *)v18; // 0x4025e0
                    int32_t v33 = v32; // 0x4025e0
                    v7 = v33;
                    v8 = v33;
                    v10 = v19 + 2;
                    if (v32 != 0) {
                        goto lab_0x4024b4;
                    } else {
                        goto lab_0x4024b2;
                    }
                } else {
                    goto lab_0x4024b2;
                }
            }
        }
    }
    // 0x4024f6
    return -(int32_t)*(char *)v17;
  lab_0x402610:;
    // 0x402610
    int32_t v34; // 0x402450
    int32_t v35 = v34;
    char v36; // 0x402450
    char v37 = v36;
    result = 93;
    int32_t v38 = v35 + 1; // 0x402615
    if (v37 == 0) {
        int32_t result2 = result; // 0x4024fd
        return result2;
    }
    goto lab_0x402617;
  lab_0x402617:;
    int32_t v39 = v38;
    char v40 = *(char *)v39; // 0x402617
    char v41 = v40; // 0x40261c
    int32_t v42 = v39; // 0x40261c
    v14 = v39;
    if (v40 == 93) {
        // break -> 0x402634
        goto lab_0x402634_2;
    }
    goto lab_0x40261e;
  lab_0x4024b2:
    // 0x4024b2
    v8 = v7;
    v10 = v18;
    goto lab_0x4024b4;
  lab_0x402575:
    // 0x402575
    v5 = *(char *)v12;
    v9 = v12;
    v16 = v17 + 1;
    goto lab_0x40247a;
  lab_0x4024b4:;
    int32_t c = v8;
    char v47 = *(char *)v17; // 0x4024b4
    int32_t c2 = v47; // 0x4024b4
    if (v47 == 0) {
        // 0x4024f2
        result = c - c2;
        goto lab_0x4024f6;
    }
    // 0x4024c0
    int32_t v48; // 0x402450
    if ((v4 & 0x4000) != 0) {
        // 0x402590
        v48 = c - c2;
    } else {
        // 0x4024ce
        v48 = tolower(c) - tolower(c2);
    }
    // 0x4024ea
    v12 = v10;
    if (v48 != 0) {
        // 0x4024f2
        result = c - c2;
        goto lab_0x4024f6;
    }
    goto lab_0x402575;
  lab_0x40256d:
    // 0x40256d
    v12 = v11;
    if (v11 == 0) {
        // 0x4024f6
        return 93;
    }
    goto lab_0x402575;
  lab_0x40261e_2:;
    char v49 = v6;
    int32_t v50 = v13;
    v41 = v49;
    v42 = v50;
    while (true) {
      lab_0x40261e:;
        int32_t v43 = v42;
        char v44 = v41;
        v36 = v44;
        v34 = v43;
        if (v44 != 127) {
            goto lab_0x402610;
        } else {
            int32_t v45 = v43 + 1;
            v38 = v45;
            if ((v4 & 32) != 0) {
                goto lab_0x402617;
            } else {
                char v46 = *(char *)v45; // 0x402626
                v36 = v46;
                v34 = v45;
                goto lab_0x402610;
            }
        }
    }
    // 0x402634
    v15 = v14;
    v11 = v15 + 1;
    goto lab_0x40256d;
}

// Address range: 0x402670 - 0x4026cc
int32_t function_402670(void) {
    // 0x402670
    int32_t v1; // 0x402670
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x40267a
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x40267d
    int32_t * v4 = (int32_t *)(v1 + 8); // 0x40268b
    int32_t * mem = realloc((int32_t *)*v4, 4 * (*v3 + *v2) + 8); // 0x402691
    if (mem == NULL) {
        // 0x4026c0
        return 1;
    }
    int32_t v5 = (int32_t)mem; // 0x402691
    *v4 = v5;
    int32_t v6 = *v3 + 1; // 0x4026a3
    *v3 = v6;
    *(int32_t *)(4 * (*v2 + v6) + v5) = 0;
    return 0;
}

// Address range: 0x4026d0 - 0x402719
int32_t function_4026d0(void) {
    // 0x4026d0
    int32_t v1; // 0x4026d0
    if (v1 != 0) {
        // 0x4026df
        function_4026d0();
    }
    // 0x4026e4
    int32_t v2; // 0x4026d0
    if (v2 != 0 == (*(int32_t *)(v1 + 8) != 0)) {
        // 0x402710
        function_402670();
    }
    // 0x4026ef
    if (*(int32_t *)(v1 + 4) != 0) {
        // 0x4026f6
        function_4026d0();
    }
    // 0x4026fd
    free((int32_t *)v1);
    return &g27;
}

// Address range: 0x402720 - 0x402fa3
int32_t function_402720(int32_t a1) {
    // 0x402720
    int32_t v1; // 0x402720
    int32_t v2 = v1; // 0x402726
    char * str2; // bp-124, 0x402720
    int32_t v3 = (int32_t)&str2; // 0x402728
    int32_t v4; // 0x402720
    int32_t v5; // 0x402720
    int32_t v6; // 0x402720
    int32_t v7; // 0x402720
    int32_t v8; // 0x402720
    int32_t v9; // 0x402720
    int32_t v10; // 0x402720
    int32_t v11; // 0x402720
    int32_t v12; // 0x402720
    int32_t v13; // 0x402aa9
    if ((v12 & 1024) != 0) {
        char * str = (char *)v2; // 0x402a93
        str2 = str;
        strlen(str);
        v13 = v3 - function_401fe0();
        int32_t v14 = (int32_t)*(char *)&v1; // 0x402ab6
        v1 = v14;
        v4 = v14;
        v9 = v2;
        v6 = v13 + 12;
        while (true) {
          lab_0x402ab9:
            // 0x402ab9
            v5 = v4;
            v10 = v9;
            v7 = v6;
            v11 = v9;
            v8 = v6;
            if (v4 == 127) {
                goto lab_0x402ae5;
            } else {
                goto lab_0x402abd;
            }
        }
    } else {
        goto lab_0x40273a;
    }
  lab_0x402b3b:;
    // 0x402b3b
    int32_t v15; // 0x402720
    char v16 = *(char *)(v15 + 2); // 0x402b3b
    int32_t v17; // 0x402720
    *(char *)v17 = 127;
    *(char *)(v17 + 1) = v16;
    int32_t v18 = v17 + 2;
    if (v16 == 0) {
        // break (via goto) -> 0x402b4c
        goto lab_0x402b4c;
    }
    int32_t v19 = v15 + 3; // 0x402b80
    unsigned char v20 = *(char *)v19; // 0x402b80
    v1 = v20;
    char v21 = v20; // 0x402b89
    int32_t v22; // 0x402720
    int32_t v23 = v22; // 0x402b89
    int32_t v24 = v18; // 0x402b89
    int32_t v25 = v19; // 0x402b89
    goto lab_0x402b18;
  lab_0x402b15:;
    // 0x402b15
    char v38; // 0x402720
    v21 = v38;
    int32_t v39; // 0x402720
    v23 = v39;
    int32_t v40; // 0x402720
    v24 = v40;
    int32_t v37; // 0x402720
    v25 = v37;
    goto lab_0x402b18;
  lab_0x402b18:;
    int32_t v26 = v25;
    int32_t v27 = v24;
    int32_t v28 = v23;
    char v29 = v21; // 0x402b18
    int32_t v30; // 0x402720
    int32_t v31; // 0x402720
    int32_t v32; // 0x402720
    if (v29 == 125) {
        int32_t v33 = v28 - 1; // 0x402b25
        if (v33 == 0) {
            // break -> 0x402c7a
            goto lab_0x402c7a;
        }
        // 0x402b2e
        *(char *)v27 = 125;
        int32_t v34 = v26 + 1;
        unsigned char v35 = *(char *)v34; // 0x402b30
        v1 = v35;
        int32_t v36 = v27 + 1; // 0x402b34
        v37 = v34;
        v38 = v35;
        v39 = v33;
        v40 = v36;
        v22 = v33;
        v17 = v36;
        v15 = v26;
        if (v35 != 127) {
            goto lab_0x402b15;
        } else {
            goto lab_0x402b3b;
        }
    } else {
        if (v29 == 44 == v28 == 1) {
            // 0x402bb9
            v1 = v26;
            goto lab_0x402bc0;
        }
        // 0x402b60
        *(char *)v27 = v29;
        v30 = v28 + (int32_t)(v29 == 123);
        v32 = v27 + 1;
        v31 = v26;
        if (v29 != 123 && v29 == 0) {
            // 0x402a83
            return (int32_t)(char *)1;
        }
        goto lab_0x402b0d;
    }
  lab_0x402c03:;
    int32_t v41 = v27; // 0x402c0a
    int32_t v42 = v26 + 1;
    unsigned char v43 = *(char *)v42;
    v1 = v43;
    *(char *)v41 = v43;
    int32_t v44 = v42; // 0x402c1e
    v41++;
    while (v43 != 0) {
        // 0x402c13
        v42 = v44 + 1;
        v43 = *(char *)v42;
        v1 = v43;
        *(char *)v41 = v43;
        v44 = v42;
        v41++;
    }
    // 0x402c20
    *(int32_t *)v13 = a1;
    int32_t v45 = function_402720((int32_t)&g27); // 0x402c34
    v1 = v45;
    if (v45 == 1) {
        // 0x402a83
        return (int32_t)(char *)1;
    }
    int32_t v46 = v26; // 0x402c48
    if (*(char *)v26 != 44) {
        // 0x402c4e
        goto lab_0x402a83;
    }
    goto lab_0x402b05;
  lab_0x402ae5:;
    int32_t v50 = v8;
    int32_t v51 = v11;
    int32_t v52 = v51 + 1; // 0x402ae5
    unsigned char v53 = *(char *)v52; // 0x402ae5
    v1 = v53;
    *(char *)v50 = 127;
    int32_t v54; // 0x402720
    int32_t v55; // 0x402720
    int32_t v56; // 0x402720
    if (v53 != 0) {
        // 0x402ba0
        *(char *)(v50 + 1) = (char)v1;
        int32_t v57 = v51 + 2; // 0x402ba3
        int32_t v58 = (int32_t)*(char *)v57; // 0x402ba6
        v1 = v58;
        v4 = v58;
        v9 = v57;
        v6 = v50 + 2;
        goto lab_0x402ab9;
    } else {
        // 0x402af4
        v54 = v1;
        v56 = v52;
        v55 = v50 + 1;
        goto lab_0x402ac1;
    }
  lab_0x402abd:
    // 0x402abd
    v54 = v5;
    v56 = v10;
    v55 = v7;
    int32_t v47 = v7; // 0x402abf
    int32_t v59 = v10; // 0x402abf
    if ((char)v5 == 123) {
        // break -> 0x402b05
        goto lab_0x402b05_3;
    }
    goto lab_0x402ac1;
  lab_0x402ac1:;
    char v60 = v54; // 0x402ac1
    int32_t v61 = v55 + 1; // 0x402ac3
    int32_t v62 = v56 + 1; // 0x402ac6
    *(char *)v55 = v60;
    int32_t v63 = v1;
    if (v60 == 0 || (char)v63 == 123) {
        // 0x402f8d
        v47 = v61;
        v59 = v62;
        if ((char)v63 == 123) {
            goto lab_0x402b05_3;
        } else {
            goto lab_0x40273a;
        }
    }
    unsigned char v64 = *(char *)v62; // 0x402ad9
    int32_t v65 = v64; // 0x402ad9
    v1 = v65;
    v5 = v65;
    v10 = v62;
    v7 = v61;
    v11 = v62;
    v8 = v61;
    if (v64 != 127) {
        goto lab_0x402abd;
    } else {
        goto lab_0x402ae5;
    }
  lab_0x402a33:;
    // 0x402a33
    int32_t v66; // 0x402720
    int32_t v67 = *(int32_t *)v66;
    int32_t v68 = v67; // 0x402a37
    int32_t v69; // 0x402720
    int32_t v70 = v69; // 0x402a37
    if (v67 == 0) {
        // break -> 0x402a39
        goto lab_0x402a39_2;
    }
    int32_t v71 = v68; // 0x402a15
    goto lab_0x402a17;
  lab_0x402a11:;
    int32_t v78 = *(int32_t *)(v66 + 4);
    v68 = v78;
    int32_t v76; // 0x402720
    v70 = v76;
    if (v78 == 0) {
        // break -> 0x402a39
        goto lab_0x402a39_2;
    }
    // 0x402a15
    v71 = v68;
    goto lab_0x402a17;
  lab_0x40290f:
    // 0x40290f
    if (function_402450() == 0) {
        // break -> 0x402923
        goto lab_0x402923_2;
    }
    goto lab_0x4028f0;
  lab_0x4028f0:;
    // 0x4028f0
    int32_t * v79; // 0x402764
    int32_t v80; // 0x4028ac
    *v79 = v80;
    int32_t v81 = function_403840((int32_t)&g27); // 0x4028f3
    int32_t v82 = v81; // 0x4028fc
    char * v83; // 0x402720
    char * v84 = v83; // 0x4028fc
    int32_t v85; // 0x402720
    int32_t v86 = v85; // 0x4028fc
    if (v81 == 0) {
        // break (via goto) -> 0x402d13
        goto lab_0x402d13_2;
    }
    goto lab_0x402902;
  lab_0x402954:;
    // 0x402954
    int32_t * v88; // 0x402720
    int32_t * v74 = v88;
    int32_t * v89; // 0x402720
    int32_t * v72 = v89;
    int32_t v87; // 0x402720
    *v74 = v87 + 12;
    int32_t * v90; // 0x402720
    int32_t v91; // 0x402923
    *v90 = v91 + 1;
    int32_t v92; // 0x402720
    int32_t v93; // 0x402948
    *v72 = v92 + v93;
    memcpy((int32_t *)v92, &g27, (int32_t)&g27);
    *v72 = v93;
    strlen((char *)&g27);
    int32_t v94; // 0x40293c
    int32_t v95 = v94 - function_401fe0(); // 0x402984
    v1 = v93;
    int32_t v96 = v95 + 12; // 0x402988
    int32_t v97 = v93; // 0x40298e
    int32_t v98 = v96; // 0x40298e
    while (true) {
        int32_t v99 = v98;
        if (*(char *)v97 != 127) {
            // 0x402990
            int32_t v100; // 0x402720
            v1 = v100;
            char v101; // 0x40299d
            *(char *)v99 = v101;
            if (v101 == 0) {
                // break -> 0x4029b9
                break;
            }
        } else {
            char v102 = *(char *)(v97 + 1); // 0x4029a5
            v1 = v97 + 2;
            *(char *)v99 = v102;
            if (v102 == 0) {
                // break -> 0x4029b9
                break;
            }
        }
        // 0x40299d
        v97 = v1;
        v98 = v99 + 1;
    }
    // 0x4029b9
    *(int32_t *)v95 = v96;
    char * v103 = _strdup((char *)&g27); // 0x4029bc
    int32_t v73 = (int32_t)v103; // 0x4029bc
    v1 = v73;
    char * v104 = (char *)3; // 0x4029c7
    int32_t v105 = v85; // 0x4029c7
    char v106; // 0x40272b
    int32_t v75; // 0x402889
    if (v103 != NULL) {
        // 0x4029cd
        v1 = v75;
        char * size = v83 == (char *)2 ? NULL : v83; // 0x4029e1
        if ((v106 & 64) != 0) {
            // 0x402d60
            v104 = size;
            v105 = v85;
            if (a1 != 0) {
                // 0x402e2b
                function_402670();
                v104 = size;
                v105 = v85;
            }
        } else {
            // 0x4029ec
            v71 = v85;
            if (v85 == 0) {
                // 0x402ea5
                *v72 = 12;
                int32_t * mem = malloc((int32_t)size); // 0x402eac
                int32_t v107 = (int32_t)mem; // 0x402eac
                v1 = v107;
                v104 = size;
                v105 = 0;
                if (mem != NULL) {
                    // 0x402e53
                    *(int32_t *)(v107 + 8) = v73;
                    *(int32_t *)(v1 + 4) = 0;
                    *(int32_t *)v1 = 0;
                    v104 = size;
                    v105 = v1;
                }
            } else {
                while (true) {
                  lab_0x402a17:
                    // 0x402a17
                    v66 = v71;
                    *v72 = v73;
                    *v74 = *(int32_t *)(v66 + 8);
                    if ((v75 & 0x4000) != 0) {
                        int32_t strcoll_rc = strcoll((char *)&g27, (char *)&g27); // 0x402a03
                        v1 = strcoll_rc;
                        v76 = strcoll_rc;
                        v69 = strcoll_rc;
                        if (strcoll_rc < 1) {
                            goto lab_0x402a33;
                        } else {
                            goto lab_0x402a11;
                        }
                    } else {
                        int32_t v77 = _stricoll((char *)&g27, (char *)&g27); // 0x402a25
                        v1 = v77;
                        v76 = v77;
                        v69 = v77;
                        if (v77 >= 0 == (v77 != 0)) {
                            goto lab_0x402a11;
                        } else {
                            goto lab_0x402a33;
                        }
                    }
                }
              lab_0x402a39_2:;
                int32_t size2 = v70; // 0x402a3c
                *v72 = 12;
                int32_t * mem2 = malloc(size2); // 0x402a46
                int32_t v108 = (int32_t)mem2; // 0x402a46
                v1 = v108;
                v104 = size;
                v105 = v85;
                if (mem2 != NULL) {
                    // 0x402a53
                    *(int32_t *)(v108 + 8) = v73;
                    *(int32_t *)(v1 + 4) = 0;
                    *(int32_t *)v1 = 0;
                    int32_t v109 = v1;
                    if (size2 < 1) {
                        // 0x402e46
                        *(int32_t *)v66 = v109;
                        v104 = size;
                        v105 = v85;
                    } else {
                        // 0x402a6e
                        *(int32_t *)(v66 + 4) = v109;
                        v104 = size;
                        v105 = v85;
                    }
                }
            }
        }
    }
    // 0x402d6b
    *v79 = v80;
    int32_t v110 = function_403840((int32_t)&g27); // 0x4028f3
    int32_t v111 = v110; // 0x4028fc
    int32_t v112 = v105; // 0x4028fc
    char * v113 = v104; // 0x4028fc
    v84 = v104;
    v86 = v105;
    if (v110 == 0) {
        // break -> 0x402d13
        goto lab_0x402d13_2;
    }
    goto lab_0x402902_2;
  lab_0x402849:;
    // 0x402849
    char v125; // 0x402720
    char v126 = v125;
    v1 = v126;
    char v127 = v126; // 0x40284f
    char v128 = 92; // 0x40284f
    int32_t v129; // 0x40276f
    int32_t v130 = v129; // 0x40284f
    if (v126 != 47 == (v126 != 92)) {
        goto lab_0x402886;
    } else {
        goto lab_0x402864;
    }
  lab_0x40273a:
    // 0x40273a
    *(int32_t *)&str2 = v2;
    int32_t len = strlen((char *)&str2); // 0x402740
    int32_t v114 = v3 - function_401fe0(); // 0x402756
    *(int32_t *)(v114 + 8) = len + 1;
    int32_t * v131 = (int32_t *)(v114 + 4); // 0x402760
    *v131 = v2;
    v79 = (int32_t *)v114;
    *v79 = v114 + 12;
    *v79 = (int32_t)memcpy(&g27, &g27, (int32_t)&g27);
    v129 = function_403100((int32_t)&g27);
    int32_t v132 = function_402120(v129); // 0x402783
    if (v132 != 0) {
        // 0x402a83
        return (int32_t)(char *)v132;
    }
    // 0x402793
    int32_t v133; // 0x402720
    if (function_402080() == 0) {
        // 0x402c7e
        *v79 = v129;
        strlen((char *)&g27);
        int32_t v134 = v114 - function_401fe0(); // 0x402c9c
        int32_t v135 = v134 + 12; // 0x402c9e
        int32_t v136 = v135; // 0x402ca4
        unsigned char v137 = *(char *)v129; // 0x402cbd
        v1 = v137;
        unsigned char v138 = v137; // 0x402cc2
        int32_t v139 = v129; // 0x402cc2
        if (v137 == 127) {
            // 0x402cc4
            v139 = v129 + 1;
            v138 = *(char *)v139;
            v1 = v138;
        }
        // 0x402cb0
        *(char *)v136 = v138;
        v136++;
        while (v138 != 0) {
            int32_t v140 = v139 + 1;
            v137 = *(char *)v140;
            v1 = v137;
            v138 = v137;
            v139 = v140;
            if (v137 == 127) {
                // 0x402cc4
                v139 = v140 + 1;
                v138 = *(char *)v139;
                v1 = v138;
            }
            // 0x402cb0
            *(char *)v136 = v138;
            v136++;
        }
        // 0x402ccd
        *(int32_t *)v134 = v135;
        if (_strdup((char *)&g27) == NULL) {
            // 0x402a83
            return (int32_t)(char *)1;
        }
        // 0x402cdf
        v133 = function_402670();
    } else {
        // 0x4027a7
        int32_t v141; // bp-44, 0x402720
        *v79 = (int32_t)&v141;
        v133 = function_402720((int32_t)&g27);
    }
    // 0x4027bf
    if (v133 != 0) {
        // 0x402a83
        return (int32_t)(char *)v133;
    }
    // 0x4027ca
    v106 = v12;
    unsigned char v142 = *(char *)(v2 + 1); // 0x4027ca
    v1 = v142;
    int32_t v143; // 0x402720
    int32_t v144; // 0x402720
    char * str3; // 0x402ee6
    int32_t v145; // 0x402f07
    int32_t v146; // 0x402f09
    switch (v142) {
        case 47: {
            goto lab_0x4027eb;
        }
        case 92: {
            goto lab_0x4027eb;
        }
        default: {
            // 0x4027d6
            bool v147; // 0x402720
            int32_t v148 = v147 ? -1 : 1; // 0x4027e3
            int32_t v149 = (int32_t)&g10; // 0x402720
            int32_t v150 = v129; // 0x402720
            int32_t v151 = 2; // 0x4027e3
            while (*(char *)v150 == *(char *)v149) {
                // 0x4027d6
                v151--;
                v149 += v148;
                v150 += v148;
                if (v151 == 0) {
                    // 0x402cf6
                    v128 = 92;
                    v130 = 0;
                    if ((v106 & 16) != 0) {
                        int32_t v152 = function_402080(); // 0x402edf
                        v128 = 92;
                        v130 = 0;
                        if (v152 != 0) {
                            goto lab_0x402886;
                        } else {
                            // 0x402eef
                            str3 = (char *)v152;
                            *v79 = v2;
                            strlen(str3);
                            v145 = v114 - function_401fe0();
                            v146 = v145 + 12;
                            v144 = v146;
                            v143 = v2;
                            goto lab_0x402f1e;
                        }
                    } else {
                        goto lab_0x402886;
                    }
                }
            }
            goto lab_0x4027eb;
        }
    }
  lab_0x402b05_3:
    // 0x402b05
    v46 = v59;
    while (true) {
      lab_0x402b05:
        // 0x402b05
        v30 = 1;
        v32 = v47;
        v31 = v46;
        while (true) {
          lab_0x402b0d:;
            int32_t v48 = v31 + 1;
            unsigned char v49 = *(char *)v48; // 0x402b0d
            v1 = v49;
            v37 = v48;
            v38 = v49;
            v39 = v30;
            v40 = v32;
            v22 = v30;
            v17 = v32;
            v15 = v31;
            if (v49 == 127) {
                goto lab_0x402b3b;
            } else {
                goto lab_0x402b15;
            }
        }
      lab_0x402c7a:
        // 0x402c7a
        v1 = v26;
        goto lab_0x402c03;
    }
  lab_0x402b4c:
    // 0x402b4c
    *(char *)v18 = 0;
    // 0x402a83
    return (int32_t)(char *)1;
  lab_0x4027eb:
    // 0x4027eb
    *v79 = v129;
    int32_t v153 = strlen((char *)&g27) + v2; // 0x4027f6
    v1 = v153;
    char v154 = *(char *)v153;
    v125 = v154;
    int32_t v155 = v153; // 0x4027fa
    if (v2 >= v153) {
        goto lab_0x402849;
    } else {
        // 0x402800
        v125 = v154;
        v155 = v153;
        if (v154 != 47 == (v154 != 92)) {
            int32_t v156 = v153 - 1; // 0x402838
            v125 = *(char *)v156;
            v155 = v156;
            if (v2 != v156) {
                char v157; // 0x402720
                while (true) {
                  lab_0x402820:;
                    // 0x402820
                    int32_t v158; // 0x402720
                    int32_t v159 = v158;
                    char v160; // 0x402720
                    char v161 = v160;
                    v1 = v159;
                    v157 = 92;
                    switch (v161) {
                        case 47: {
                            goto lab_0x402849_2;
                        }
                        case 92: {
                            goto lab_0x402849_3;
                        }
                        default: {
                            int32_t v162 = v159 - 1; // 0x402838
                            char v163 = *(char *)v162;
                            v160 = v163;
                            v158 = v162;
                            v125 = v163;
                            v155 = v162;
                            if (v2 == v162) {
                                goto lab_0x402849;
                            }
                            goto lab_0x402820;
                        }
                    }
                }
              lab_0x402849_2:
                // 0x402849
                v157 = 47;
              lab_0x402849_3:;
                char v164 = v157;
                v1 = v164;
                v127 = v164;
                goto lab_0x402864;
            } else {
                goto lab_0x402849;
            }
        } else {
            goto lab_0x402849;
        }
    }
  lab_0x402886:;
    // 0x402886
    int32_t v165; // 0x402720
    int32_t v166 = *(int32_t *)v165; // 0x402896
    v1 = v166;
    if (v166 == 0) {
        // 0x402dba
        free((int32_t *)v165);
        // 0x402a83
        return (int32_t)(char *)2;
    }
    char v123 = v128;
    v75 = 0x1000000 * v12 / 0x1000000;
    int32_t v167 = v166; // 0x402720
    char * v168 = (char *)2; // 0x402720
    int32_t * v169; // 0x402720
    int32_t v170; // 0x402720
    int32_t v171; // 0x402720
    char * v172; // 0x402720
    int32_t v173; // 0x402720
    while (true) {
        // 0x4028a9
        int32_t v174; // 0x402720
        v173 = v174;
        char * v175 = v168;
        *v79 = v167;
        v80 = function_403680(v173);
        char * v176; // 0x402720
        if (v80 == 0) {
            if ((v106 & 4) != 0) {
                // break -> 0x402d73
                break;
            }
            // 0x402e66
            v176 = v175;
            int32_t v177; // 0x402720
            if (v177 != 0) {
                // 0x402e71
                *v131 = *_errno();
                int32_t * v178 = (int32_t *)v173;
                int32_t v179 = *v178; // 0x402e7f
                *v79 = v179;
                v176 = v175;
                v169 = v178;
                if (v179 != 0) {
                    goto lab_0x402d85;
                }
            }
        } else {
            char * len2 = NULL; // 0x4028c0
            if (v130 != 0) {
                // 0x4028c6
                *v79 = *(int32_t *)v173;
                len2 = (char *)strlen((char *)&g27);
            }
            char * v115 = len2;
            *v79 = v80;
            int32_t v180 = function_403840((int32_t)&g27); // 0x4028f3
            if (v180 == 0) {
                // 0x402d13
                *v79 = v80;
                function_403890((int32_t)&g27);
                v176 = v175;
            } else {
                int32_t v118 = (int32_t)v115;
                int32_t * v120 = (int32_t *)v173;
                int32_t v122 = v118 + 11;
                int32_t v124 = v118 + 1;
                v111 = v180;
                v112 = 0;
                v113 = v175;
                while (true) {
                  lab_0x402902_2:
                    // 0x402902
                    v83 = v113;
                    v85 = v112;
                    v82 = v111;
                    while (true) {
                      lab_0x402902:
                        // 0x402902
                        v87 = v82;
                        if ((int16_t)v75 > -1) {
                            goto lab_0x40290f;
                        } else {
                            // 0x402909
                            if (*(int32_t *)(v87 + 8) != 16) {
                                goto lab_0x4028f0;
                            } else {
                                goto lab_0x40290f;
                            }
                        }
                    }
                  lab_0x402923_2:
                    // 0x402923
                    v91 = (int32_t)*(int16_t *)(v87 + 6);
                    v94 = v114 - function_401fe0();
                    v93 = v94 + 12;
                    if (v115 != NULL) {
                        int32_t * v116 = (int32_t *)v94;
                        *v116 = v93;
                        int32_t * v117 = (int32_t *)(v94 + 8);
                        *v117 = v118;
                        int32_t * v119 = (int32_t *)(v94 + 4);
                        *v119 = *v120;
                        memcpy((int32_t *)v91, &g27, (int32_t)&g27);
                        unsigned char v121 = *(char *)(v122 + v94); // 0x402df1
                        v1 = v121;
                        v89 = v116;
                        v90 = v117;
                        v88 = v119;
                        v92 = v118;
                        switch (v121) {
                            case 47: {
                                goto lab_0x402954;
                            }
                            case 92: {
                                goto lab_0x402954;
                            }
                            default: {
                                // 0x402dfe
                                *(char *)(v93 + v118) = v123;
                                v89 = v116;
                                v90 = v117;
                                v88 = v119;
                                v92 = v124;
                                goto lab_0x402954;
                            }
                        }
                    } else {
                        // 0x402923
                        v89 = (int32_t *)v94;
                        v90 = (int32_t *)(v94 + 8);
                        v88 = (int32_t *)(v94 + 4);
                        v92 = 0;
                        goto lab_0x402954;
                    }
                }
              lab_0x402d13_2:;
                char * v181 = v84;
                *v79 = v80;
                function_403890((int32_t)&g27);
                v176 = v181;
                if (v86 != 0) {
                    // 0x402d22
                    function_4026d0();
                    v176 = v181;
                }
            }
        }
        int32_t v182 = v173 + 4;
        *v79 = *(int32_t *)v173;
        free(&g27);
        int32_t * v183 = (int32_t *)v182;
        int32_t v184 = *v183; // 0x402d3e
        v1 = v184;
        v172 = v176;
        if (v184 == 0) {
            // 0x402dba
            free((int32_t *)v165);
            // 0x402a83
            return (int32_t)v172;
        }
        // 0x402d49
        v167 = v184;
        v168 = v176;
        v174 = v182;
        if (v176 == (char *)1) {
            // 0x402d96
            v170 = *v183;
            v171 = v182;
            goto lab_0x402d96_2;
        }
    }
    // 0x402d73
    v169 = (int32_t *)v173;
  lab_0x402d85:
    // 0x402d85
    v1 = v173;
    int32_t v185 = v173 + 4;
    *v79 = *v169;
    free(&g27);
    int32_t v186 = *(int32_t *)v185; // 0x402d8f
    v170 = v186;
    v171 = v185;
    if (v186 == 0) {
        // 0x402dba
        free((int32_t *)v165);
        // 0x402a83
        return (int32_t)(char *)1;
    }
    goto lab_0x402d96_2;
  lab_0x402864:;
    int32_t v217 = v155 + 1; // 0x402864
    unsigned char v218 = *(char *)v217; // 0x402867
    v1 = v218;
    char v219 = v218; // 0x402876
    int32_t v220 = v217; // 0x402876
    v128 = v127;
    v130 = v129;
    if (v218 == 47 || v218 == 92) {
        int32_t v221 = v220 + 1; // 0x402864
        unsigned char v222 = *(char *)v221; // 0x402867
        v1 = v222;
        v220 = v221;
        v128 = v219;
        v130 = v129;
        while (v222 == 47 || v222 == 92) {
            char v223 = v222;
            v221 = v220 + 1;
            v222 = *(char *)v221;
            v1 = v222;
            v220 = v221;
            v128 = v223;
            v130 = v129;
        }
    }
    goto lab_0x402886;
  lab_0x402d96_2:
    // 0x402d96
    v1 = v170;
    int32_t v187 = v171 + 4; // 0x402d9c
    *v79 = v170;
    free(&g27);
    int32_t v188 = *(int32_t *)v187; // 0x402da7
    v1 = v188;
    int32_t v189 = v187; // 0x402dab
    v172 = (char *)1;
    while (v188 != 0) {
        // 0x402d9c
        v187 = v189 + 4;
        *v79 = v188;
        free(&g27);
        v188 = *(int32_t *)v187;
        v1 = v188;
        v189 = v187;
        v172 = (char *)1;
    }
  lab_0x402dba:
    // 0x402dba
    free((int32_t *)v165);
    // 0x402a83
    return (int32_t)v172;
  lab_0x402bc0:;
    // 0x402bc0
    int32_t v190; // 0x402720
    int32_t v191 = v190;
    int32_t v192; // 0x402720
    int32_t v193 = v192;
    int32_t v194 = v193; // 0x402720
    goto lab_0x402bc0_2;
  lab_0x402bc0_2:;
    int32_t v195 = v194;
    int32_t v196 = v195 + 1; // 0x402bc0
    char v197 = *(char *)v196; // 0x402bc0
    int32_t v198; // 0x402720
    char v199; // 0x402720
    int32_t v200; // 0x402720
    if (v197 != 127) {
        // 0x402cef
        v1 = v196;
        v198 = v196;
        v199 = v197;
        goto lab_0x402bf4;
    } else {
        char v201 = *(char *)(v195 + 2); // 0x402bd0
        v200 = v196;
        if (v201 != 0) {
            goto lab_0x402be8;
        } else {
            // 0x402c60
            *(char *)v27 = 0;
            goto lab_0x402a83;
        }
    }
  lab_0x402bf4:;
    char v202 = v199;
    int32_t v203 = v198;
    int32_t v204; // 0x402720
    if (v202 == 123) {
        // 0x402c72
        v204 = v191 + 1;
        goto lab_0x402bc0_3;
    } else {
        if (v202 != 125) {
            // 0x402c53
            v194 = v203;
            if (v202 != 0) {
                goto lab_0x402bc0_2;
            } else {
                // 0x402c60
                *(char *)v27 = 0;
                goto lab_0x402a83;
            }
        } else {
            int32_t v205 = v191 - 1; // 0x402bfe
            v204 = v205;
            if (v205 != 0) {
                goto lab_0x402bc0_3;
            } else {
                goto lab_0x402c03;
            }
        }
    }
  lab_0x402be8:;
    int32_t v206 = v200;
    int32_t v207 = v206 + 2; // 0x402be8
    char v208 = *(char *)v207; // 0x402be8
    v1 = v207;
    v198 = v207;
    v199 = v208;
    if (v208 == 127) {
        char v209 = *(char *)(v206 + 3); // 0x402be0
        v200 = v207;
        if (v209 == 0) {
            // 0x402c60
            *(char *)v27 = 0;
            goto lab_0x402a83;
        } else {
            goto lab_0x402be8;
        }
    } else {
        goto lab_0x402bf4;
    }
  lab_0x402bc0_3:;
    int32_t v210 = v204;
    v192 = v203;
    v190 = v210;
    goto lab_0x402bc0;
  lab_0x402f1e:;
    int32_t v211 = v143;
    unsigned char v212 = *(char *)v211; // 0x402f1e
    v1 = v212;
    char v213 = v212; // 0x402f23
    int32_t v214 = v211; // 0x402f23
    if (v212 != 127) {
        goto lab_0x402f11;
    } else {
        int32_t v215 = v211 + 1; // 0x402f25
        unsigned char v216 = *(char *)v215; // 0x402f25
        v1 = v216;
        v213 = v216;
        v214 = v215;
        goto lab_0x402f11;
    }
  lab_0x402f11:
    // 0x402f11
    *(char *)v144 = v213;
    v144++;
    v143 = v214 + 1;
    if (v213 == 0) {
        // 0x402f2e
        *(int32_t *)v145 = v146;
        if (a1 == 0 | _strdup((char *)&g27) == NULL) {
            goto lab_0x402dba;
        } else {
            // 0x402f4b
            function_402670();
            v172 = str3;
            goto lab_0x402dba;
        }
    } else {
        goto lab_0x402f1e;
    }
}

// Address range: 0x402fb0 - 0x403093
int32_t function_402fb0(int32_t str, int32_t a2, int32_t a3, int32_t a4) {
    // 0x402fb0
    if ((a2 & 2) == 0 == (a4 != 0)) {
        // 0x403003
        *(int32_t *)(a4 + 12) = 0;
    }
    int32_t * v1 = (int32_t *)a4; // 0x402fce
    if (*v1 != (int32_t)"glob-1.0-mingw32") {
        // 0x402fd6
        int32_t v2; // 0x402fb0
        function_402120(v2);
        *v1 = (int32_t)"glob-1.0-mingw32";
    }
    int32_t v3 = a4; // bp-60, 0x402fe3
    int32_t result = function_402720(a4); // 0x402fed
    if ((a2 & 16) == 0 || result != 2) {
        // 0x402ff9
        return result;
    }
    // 0x403015
    v3 = str;
    strlen((char *)str);
    int32_t v4 = (int32_t)&v3 - function_401fe0(); // 0x403034
    int32_t v5 = v4 + 4; // 0x403036
    int32_t v6 = v5; // 0x40303c
    int32_t v7 = str; // 0x40303c
    while (true) {
        int32_t v8 = v7;
        int32_t v9 = v6;
        char v10 = *(char *)v8; // 0x40304d
        int32_t v11 = v8 + 1;
        if (v10 != 127) {
            // 0x403040
            *(char *)v9 = v10;
            v7 = v11;
            if (v10 == 0) {
                // break -> 0x403068
                break;
            }
        } else {
            char v12 = *(char *)v11; // 0x403054
            *(char *)v9 = v12;
            v7 = v8 + 2;
            if (v12 == 0) {
                // break -> 0x403068
                break;
            }
        }
        // 0x40304d
        v6 = v9 + 1;
    }
    // 0x403068
    *(int32_t *)v4 = v5;
    if (_strdup((char *)2) != NULL) {
        // 0x403081
        function_402670();
    }
    // 0x402ff9
    return result;
}

// Address range: 0x4030a0 - 0x4030ff
int32_t function_4030a0(int32_t a1) {
    // 0x4030a0
    if (*(int32_t *)a1 != (int32_t)"glob-1.0-mingw32") {
        // 0x4030b2
        int32_t result; // 0x4030a0
        return result;
    }
    int32_t v1 = *(int32_t *)(a1 + 4); // 0x4030c0
    if (v1 < 1) {
        // 0x4030ed
        free((int32_t *)*(int32_t *)(a1 + 8));
        return &g27;
    }
    int32_t * v2 = (int32_t *)(a1 + 8);
    int32_t v3 = 4 * *(int32_t *)(a1 + 12); // 0x4030a0
    int32_t v4 = v1;
    v4--;
    free((int32_t *)*(int32_t *)(*v2 + v3));
    v3 += 4;
    while (v4 != 0) {
        // 0x4030d4
        v4--;
        free((int32_t *)*(int32_t *)(*v2 + v3));
        v3 += 4;
    }
    // 0x4030ed
    free((int32_t *)*v2);
    return &g27;
}

// Address range: 0x403100 - 0x4034f4
int32_t function_403100(int32_t result) {
    int16_t * v1 = (int16_t *)2; // bp-60, 0x403111
    char * locale = setlocale(LC_TIME, NULL); // 0x403118
    char * v2 = NULL; // 0x403121
    if (locale != NULL) {
        // 0x403123
        v1 = (int16_t *)locale;
        v2 = _strdup(locale);
    }
    int32_t v3 = (int32_t)&v1; // 0x403106
    int32_t v4 = (int32_t)v2;
    v1 = (int16_t *)2;
    setlocale(LC_TIME, (char *)&g11);
    int16_t * v5; // 0x403100
    int16_t v6; // 0x403100
    int32_t v7; // 0x4031f0
    int32_t * v8; // 0x4031f2
    int32_t v9; // 0x4031f9
    int32_t * v10; // 0x4031fd
    int32_t * v11; // 0x403200
    uint32_t locale_category; // 0x403204
    int16_t * v12; // 0x403215
    int16_t v13; // 0x403215
    if (result == 0) {
        goto lab_0x403150;
    } else {
        char * src = (char *)result; // 0x40314b
        if (*src != 0) {
            // 0x4031c1
            v1 = NULL;
            int32_t v14 = mbstowcs(NULL, src, 0); // 0x4031da
            v7 = v3 - function_401fe0();
            v8 = (int32_t *)(v7 + 8);
            *v8 = v14;
            v9 = v7 + 12;
            v10 = (int32_t *)v7;
            *v10 = v9;
            v11 = (int32_t *)(v7 + 4);
            *v11 = result;
            locale_category = mbstowcs((int16_t *)&g27, (char *)&g27, (int32_t)&g27);
            *(int16_t *)(2 * locale_category + v9) = 0;
            v12 = (int16_t *)v9;
            v13 = *v12;
            v5 = v12;
            v6 = v13;
            if (locale_category < 2) {
                goto lab_0x403240;
            } else {
                switch (v13) {
                    case 47: {
                        goto lab_0x403447;
                    }
                    case 92: {
                        goto lab_0x403447;
                    }
                    default: {
                        // 0x403235
                        v5 = v12;
                        v6 = v13;
                        if (*(int16_t *)(v7 + 14) == 58) {
                            int16_t * v15 = (int16_t *)(v7 + 16); // 0x403492
                            v5 = v15;
                            v6 = *v15;
                        }
                        goto lab_0x403240;
                    }
                }
            }
        } else {
            goto lab_0x403150;
        }
    }
  lab_0x403291:;
    // 0x403291
    int32_t v16; // 0x403100
    int32_t v17 = v16;
    int32_t v18 = v17; // 0x403100
    int32_t v19; // 0x403100
    int16_t v20; // 0x403100
    int16_t v21; // 0x403100
    int32_t v22; // 0x403100
    switch (v21) {
        case 92: {
            goto lab_0x403285;
        }
        case 0: {
            goto lab_0x4032aa;
        }
        default: {
            int32_t v23 = v17 + 2; // 0x40329c
            int16_t v24 = *(int16_t *)v23; // 0x40329c
            v19 = v23;
            v20 = v24;
            v22 = v17;
            if (v24 == 0) {
                // break -> 0x4032aa
                break;
            }
            goto lab_0x403274_2;
        }
    }
  lab_0x4034ad:;
    // 0x4034ad
    int32_t v25; // 0x403100
    int32_t v26 = v25; // 0x4034ad
    int32_t v27; // 0x403100
    int16_t v28; // 0x403100
    uint32_t v29; // 0x40324d
    if (v25 != v29) {
        goto lab_0x40335e;
    } else {
        // 0x4034b3
        v26 = v25;
        if (v28 != 47 == (v28 != 92)) {
            goto lab_0x40335e;
        } else {
            // 0x4034c7
            v26 = v25;
            if (*(int16_t *)v27 != v28) {
                goto lab_0x40335e;
            } else {
                // 0x4034d5
                v26 = v25;
                int32_t v30; // 0x403100
                switch (*(int16_t *)(v30 + 2)) {
                    case 47: {
                        goto lab_0x40335e;
                    }
                    case 92: {
                        goto lab_0x40335e;
                    }
                    default: {
                        // 0x4034ed
                        v26 = v27;
                        goto lab_0x40335e;
                    }
                }
            }
        }
    }
  lab_0x403340:;
    // 0x403340
    int32_t v31; // 0x403100
    int32_t v32 = v31 - 2; // 0x403340
    int32_t v33 = v32; // 0x403346
    v27 = v31;
    v25 = v32;
    if (v32 <= v29) {
        goto lab_0x4034ad;
    }
    goto lab_0x40334c;
  lab_0x40335e:
    // 0x40335e
    *(int16_t *)(v26 + 2) = 0;
    int16_t v34 = *v12; // 0x403366
    int32_t v35 = v9; // 0x40336d
    int16_t v36 = v34; // 0x40336d
    int32_t v37 = v9; // 0x40336d
    int32_t v38; // 0x403100
    int16_t v39; // 0x403100
    if (v34 != 47 == (v34 != 92)) {
        goto lab_0x40347d;
    } else {
        int32_t v40; // 0x403380
        int16_t v41; // 0x403383
        while (true) {
          lab_0x403380_2:
            // 0x403380
            v40 = v35 + 2;
            v41 = *(int16_t *)v40;
            switch (v41) {
                case 47: {
                    // 0x403380
                    v35 = v40;
                    goto lab_0x403380_2;
                }
                case 92: {
                    // 0x403380
                    v35 = v40;
                    goto lab_0x403380_2;
                }
                default: {
                    goto lab_0x403392;
                }
            }
        }
      lab_0x403392:
        // 0x403392
        v38 = v9;
        v39 = v34;
        v36 = v41;
        v37 = v40;
        if (v40 - v9 < 6) {
            goto lab_0x40347d;
        } else {
            goto lab_0x4033a1;
        }
    }
  lab_0x403285:;
    int32_t v42 = v18; // 0x403100
    while (true) {
        int32_t v43 = v42 + 2; // 0x403285
        int16_t v44 = *(int16_t *)v43; // 0x403288
        v42 = v43;
        v16 = v43;
        v21 = v44;
        if (v44 != 47) {
            goto lab_0x403291;
        }
    }
  lab_0x403150:;
    int32_t * v45 = (int32_t *)(v3 + 8); // 0x403150
    *v45 = 0;
    int32_t * v46 = (int32_t *)(v3 + 4); // 0x403158
    *v46 = (int32_t)&g12;
    *(int32_t *)&v1 = 0;
    int32_t v47 = wcstombs((char *)&g27, (int16_t *)&g27, (int32_t)&g27) + 1; // 0x40316c
    *v46 = v47;
    *(int32_t *)&v1 = g25;
    int32_t mem = (int32_t)realloc(&g27, (int32_t)&g27); // 0x40317b
    g25 = mem;
    *v45 = v47;
    *v46 = (int32_t)&g12;
    *(int32_t *)&v1 = mem;
    wcstombs((char *)&g27, (int16_t *)&g27, (int32_t)&g27);
    *v46 = v4;
    *(int32_t *)&v1 = 2;
    setlocale((int32_t)&g27, (char *)&g27);
    *(int32_t *)&v1 = v4;
    free(&g27);
    return g25;
  lab_0x403240:;
    int16_t v48 = v6; // 0x403247
    int16_t * v49 = v5; // 0x403247
    if (v6 == 0) {
        goto lab_0x403150;
    } else {
        goto lab_0x40324d;
    }
  lab_0x40324d:
    // 0x40324d
    v28 = v48;
    v29 = (int32_t)v49;
    v19 = v29;
    v20 = v28;
    v22 = v29;
    int32_t v50; // 0x403100
    while (true) {
      lab_0x403274_2:
        // 0x403274
        v50 = v22;
        int32_t v51 = v19; // 0x403100
        int16_t v52 = v20; // 0x403100
        int32_t v53; // 0x403100
        while (true) {
          lab_0x403274:
            // 0x403274
            v53 = v51;
            switch (v52) {
                case 92: {
                    goto lab_0x40327a;
                }
                case 47: {
                    goto lab_0x40327a;
                }
                default: {
                    int32_t v54 = v53 + 2; // 0x403268
                    int16_t v55 = *(int16_t *)v54; // 0x403268
                    v51 = v54;
                    v52 = v55;
                    if (v55 == 0) {
                        // break (via goto) -> 0x4032aa
                        goto lab_0x4032aa;
                    }
                    goto lab_0x403274;
                }
            }
        }
      lab_0x40327a:;
        int16_t v56 = *(int16_t *)v53; // 0x40327a
        v18 = v53;
        v16 = v53;
        v21 = v56;
        if (v56 != 47) {
            goto lab_0x403291;
        } else {
            goto lab_0x403285;
        }
    }
  lab_0x4032aa:;
    // 0x4032aa
    int32_t result2; // 0x403100
    if (v50 > v29) {
        int32_t v57 = v50 - 2; // 0x403340
        v33 = v57;
        v27 = v50;
        v25 = v57;
        if (v57 <= v29) {
            goto lab_0x4034ad;
        } else {
            while (true) {
              lab_0x40334c:
                // 0x40334c
                v31 = v33;
                v26 = v31;
                switch (*(int16_t *)v31) {
                    case 47: {
                        goto lab_0x403340;
                    }
                    case 92: {
                        goto lab_0x403340;
                    }
                    default: {
                        goto lab_0x40335e;
                    }
                }
            }
            goto lab_0x40335e;
        }
    } else {
        switch (v28) {
            default: {
                // 0x4032cb
                *v49 = 46;
            }
            case 47: {
            }
            case 92: {
                // 0x4032db
                *(int16_t *)(v29 + 2) = 0;
                *v8 = 0;
                *v11 = v9;
                *v10 = 0;
                int32_t v58 = wcstombs((char *)&g27, (int16_t *)&g27, (int32_t)&g27) + 1; // 0x4032f8
                *v11 = v58;
                *v10 = g25;
                int32_t mem2 = (int32_t)realloc((int32_t *)v58, (int32_t)&g27); // 0x40330a
                g25 = mem2;
                *v11 = v9;
                *v10 = mem2;
                *v8 = v58;
                wcstombs((char *)&g27, (int16_t *)&g27, (int32_t)&g27);
                result2 = mem2;
                // break -> 0x4033f0
                break;
            }
        }
        goto lab_0x4033f0;
    }
  lab_0x403447:
    // 0x403447
    v48 = v13;
    v49 = v12;
    if (v13 == *(int16_t *)(v7 + 14)) {
        // 0x403455
        v48 = v13;
        v49 = v12;
        if (*(int16_t *)(v7 + 16) == 0) {
            // 0x403460
            *v11 = v4;
            *v10 = 2;
            setlocale(locale_category, (char *)&g27);
            *v10 = v4;
            free(&g27);
            // 0x403408
            return result;
        }
    }
    goto lab_0x40324d;
  lab_0x4033f0:
    // 0x4033f0
    *v11 = v4;
    *v10 = 2;
    setlocale((int32_t)&g27, (char *)&g27);
    *v10 = v4;
    free(&g27);
    // 0x403408
    return result2;
  lab_0x40347d:;
    int16_t v59 = *(int16_t *)(v7 + 14); // 0x40347d
    v38 = v59 != v34 ? v9 : v37;
    v39 = v59 != v34 ? v34 : v36;
    goto lab_0x4033a1;
  lab_0x4033a1:;
    int16_t v60 = v39; // 0x4033a6
    int32_t v61 = v38; // 0x4033a6
    int32_t v62 = v38; // 0x4033a6
    int32_t v63 = v38; // 0x4033a6
    if (v39 != 0) {
        while (true) {
            int16_t v64 = v60; // 0x4033be
            int32_t v65 = v62;
            int32_t v66 = v61 + 2; // 0x4033a8
            *(int16_t *)v61 = v64;
            int32_t v67 = v65; // 0x4033b3
            while (v64 != 47) {
                int32_t v68 = v65 + 2; // 0x4033b9
                v67 = v68;
                if (*(int16_t *)v65 == 92) {
                    // break -> 0x403417
                    break;
                }
                // 0x4033be
                v64 = *(int16_t *)v68;
                int32_t v69 = v66; // 0x4033c7
                v63 = v66;
                if (v64 == 0) {
                    // break (via goto) -> 0x4033c9
                    goto lab_0x4033c9;
                }
                v65 = v68;
                v66 = v69 + 2;
                *(int16_t *)v69 = v64;
                v67 = v65;
            }
            int16_t v70 = *(int16_t *)v67; // 0x403417
            int32_t v71 = v67; // 0x40341e
            int16_t v72 = v70; // 0x40341e
            int32_t v73 = v67; // 0x40341e
            if (v70 != 92 != v70 != 47) {
                while (true) {
                  lab_0x403430_2:;
                    int32_t v74 = v73 + 2; // 0x403430
                    int16_t v75 = *(int16_t *)v74; // 0x403433
                    v71 = v74;
                    v72 = v75;
                    switch (v75) {
                        case 47: {
                            // 0x403430
                            v73 = v74;
                            goto lab_0x403430_2;
                        }
                        case 92: {
                            // 0x403430
                            v73 = v74;
                            goto lab_0x403430_2;
                        }
                        default: {
                            goto lab_0x4033a3;
                        }
                    }
                }
            }
          lab_0x4033a3:
            // 0x4033a3
            v60 = v72;
            v61 = v66;
            v62 = v71;
            v63 = v66;
            if (v72 == 0) {
                // break -> 0x4033c9
                break;
            }
        }
    }
  lab_0x4033c9:
    // 0x4033c9
    *(int16_t *)v63 = 0;
    *v11 = v9;
    *v8 = locale_category;
    *v10 = result;
    int32_t v76 = wcstombs((char *)&g27, (int16_t *)&g27, (int32_t)&g27); // 0x4033df
    result2 = result;
    if (v76 != -1) {
        // 0x4033ec
        *(char *)(v76 + result) = 0;
        result2 = result;
    }
    goto lab_0x4033f0;
}

// Address range: 0x403500 - 0x4035cf
int32_t function_403500(void) {
    // 0x403500
    int32_t lpFindFileData; // bp-332, 0x403500
    int32_t lpFileName; // 0x403500
    int32_t * v1 = FindFirstFileA((char *)lpFileName, (struct _WIN32_FIND_DATAA *)&lpFindFileData); // 0x403515
    int32_t result = (int32_t)v1; // 0x403515
    if (v1 == (int32_t *)-1) {
        int32_t * v2 = _errno(); // 0x40357e
        int32_t errorCode = GetLastError(); // 0x403585
        *v2 = errorCode;
        int32_t * v3 = _errno();
        if (errorCode == 3) {
            // 0x4035c2
            *v3 = 2;
            // 0x403563
            return result;
        }
        int32_t * v4 = _errno();
        if (*v3 == 267) {
            // 0x4035b5
            *v4 = 20;
            // 0x403563
            return result;
        }
        // 0x40359e
        if (*v4 != 2) {
            // 0x4035a8
            *_errno() = 22;
        }
        // 0x403563
        return result;
    }
    // 0x403524
    int32_t v5; // 0x403500
    int32_t v6 = v5 + 12; // 0x403526
    int16_t * v7 = (int16_t *)(v5 + 6); // 0x403529
    *v7 = 0;
    int32_t v8; // bp-356, 0x403500
    int32_t v9 = (int32_t)&v8 + 60; // 0x403546
    char v10 = *(char *)v9; // 0x403546
    *(char *)v6 = v10;
    if (v10 != 0) {
        uint16_t v11 = *v7 + 1;
        *v7 = v11;
        int32_t v12 = v6 + (int32_t)(v11 < 260); // 0x403540
        char v13 = *(char *)(v9 + (int32_t)v11); // 0x403546
        *(char *)v12 = v13;
        int32_t v14 = v12; // 0x40354f
        while (v13 != 0) {
            // 0x403531
            v11 = *v7 + 1;
            *v7 = v11;
            v12 = v14 + (int32_t)(v11 < 260);
            v13 = *(char *)(v9 + (int32_t)v11);
            *(char *)v12 = v13;
            v14 = v12;
        }
    }
    // 0x403551
    char v15; // 0x403500
    uint32_t v16 = (int32_t)v15 & -256 | (int32_t)(v15 & 88); // 0x403555
    int32_t * v17 = (int32_t *)(v5 + 8);
    if (v16 < 17) {
        // 0x403570
        *v17 = v16;
        return result;
    }
    // 0x40355c
    *v17 = 24;
    // 0x403563
    return result;
}

// Address range: 0x4035d0 - 0x403672
int32_t function_4035d0(void) {
    // 0x4035d0
    int32_t lpFindFileData; // bp-332, 0x4035d0
    int32_t hFindFile; // 0x4035d0
    bool v1 = FindNextFileA((int32_t *)hFindFile, (struct _WIN32_FIND_DATAA *)&lpFindFileData); // 0x4035e5
    int32_t result = v1; // 0x4035e5
    if (!v1) {
        // 0x403652
        if (GetLastError() == 18) {
            // 0x40362e
            return result;
        }
        // 0x40365c
        *_errno() = 2;
        return 0;
    }
    // 0x4035f3
    int32_t v2; // 0x4035d0
    int32_t v3 = v2 + 12; // 0x4035f5
    int16_t * v4 = (int16_t *)(v2 + 6); // 0x4035f8
    *v4 = 0;
    int32_t v5; // bp-356, 0x4035d0
    int32_t v6 = (int32_t)&v5 + 60; // 0x403615
    char v7 = *(char *)v6; // 0x403615
    *(char *)v3 = v7;
    int32_t v8 = v3; // 0x40361e
    if (v7 != 0) {
        uint16_t v9 = *v4 + 1;
        *v4 = v9;
        v8 += (int32_t)(v9 < 260);
        char v10 = *(char *)(v6 + (int32_t)v9); // 0x403615
        *(char *)v8 = v10;
        while (v10 != 0) {
            // 0x403600
            v9 = *v4 + 1;
            *v4 = v9;
            v8 += (int32_t)(v9 < 260);
            v10 = *(char *)(v6 + (int32_t)v9);
            *(char *)v8 = v10;
        }
    }
    // 0x403620
    char v11; // 0x4035d0
    uint32_t v12 = (int32_t)v11 & -256 | (int32_t)(v11 & 88); // 0x403624
    int32_t * v13 = (int32_t *)(v2 + 8);
    if (v12 >= 17) {
        // 0x403640
        *v13 = 24;
        return result;
    }
    // 0x40362b
    *v13 = v12;
    // 0x40362e
    return result;
}

// Address range: 0x403680 - 0x403837
int32_t function_403680(int32_t a1) {
    if (a1 == 0) {
        // 0x40381c
        *_errno() = 22;
        // 0x4037d1
        return 0;
    }
    char * v1 = (char *)a1; // 0x403699
    if (*v1 == 0) {
        // 0x403800
        *_errno() = 2;
        // 0x4037d1
        return 0;
    }
    // 0x4036a2
    char * v2; // bp-316, 0x403680
    int32_t v3 = (int32_t)&v2; // 0x403684
    int32_t v4; // bp-288, 0x403680
    int32_t v5 = &v4; // 0x4036a2
    v2 = (char *)&v4;
    _fullpath((char *)&v4, v1, 260);
    int32_t v6; // 0x403680
    if ((char)v4 == 0) {
        int32_t v7 = v5;
        int32_t v8 = *(int32_t *)v7; // 0x403710
        int32_t v9 = v7 + 4; // 0x403712
        int32_t v10 = v8 - 0x1010101 & (v8 ^ -0x7f7f7f80); // 0x40371d
        uint32_t v11 = v10 & -0x7f7f7f80; // 0x40371f
        while (v11 == 0) {
            // 0x403710
            v7 = v9;
            v8 = *(int32_t *)v7;
            v9 = v7 + 4;
            v10 = v8 - 0x1010101 & (v8 ^ -0x7f7f7f80);
            v11 = v10 & -0x7f7f7f80;
        }
        int32_t v12 = (v10 & 0x8080) == 0 ? v7 + 6 : v9;
        unsigned char v13 = (char)((v10 & 0x8080) == 0 ? v11 / 0x10000 : v11); // 0x403735
        v6 = v12 - v5 + (-1 - v13 < v13 ? -4 : -3);
        goto lab_0x40373c;
    } else {
        int32_t v14 = v5;
        int32_t v15 = *(int32_t *)v14; // 0x4036c3
        int32_t v16 = v14 + 4; // 0x4036c5
        int32_t v17 = v15 - 0x1010101 & (v15 ^ -0x7f7f7f80); // 0x4036d0
        uint32_t v18 = v17 & -0x7f7f7f80; // 0x4036d2
        while (v18 == 0) {
            // 0x4036c3
            v14 = v16;
            v15 = *(int32_t *)v14;
            v16 = v14 + 4;
            v17 = v15 - 0x1010101 & (v15 ^ -0x7f7f7f80);
            v18 = v17 & -0x7f7f7f80;
        }
        unsigned char v19 = (char)((v17 & 0x8080) == 0 ? v18 / 0x10000 : v18); // 0x4036e8
        int32_t v20 = ((v17 & 0x8080) == 0 ? v14 + 6 : v16) - (-1 - v19 < v19 ? 4 : 3); // 0x4036ea
        int32_t v21 = v20 - v5; // 0x4036ed
        v6 = v21;
        switch (*(char *)(v3 + 27 + v21)) {
            case 47: {
                goto lab_0x40373c;
            }
            case 92: {
                goto lab_0x40373c;
            }
            default: {
                // 0x4036fe
                *(int16_t *)v20 = 92;
                v6 = v21 + 1;
                goto lab_0x40373c;
            }
        }
    }
  lab_0x40373c:
    // 0x40373c
    *(int16_t *)(v6 + v5) = 42;
    int32_t v22 = v5;
    int32_t v23 = *(int32_t *)v22; // 0x403747
    int32_t v24 = v22 + 4; // 0x403749
    int32_t v25 = v23 - 0x1010101 & (v23 ^ -0x7f7f7f80); // 0x403754
    uint32_t v26 = v25 & -0x7f7f7f80; // 0x403756
    while (v26 == 0) {
        // 0x403747
        v22 = v24;
        v23 = *(int32_t *)v22;
        v24 = v22 + 4;
        v25 = v23 - 0x1010101 & (v23 ^ -0x7f7f7f80);
        v26 = v25 & -0x7f7f7f80;
    }
    unsigned char v27 = (char)((v25 & 0x8080) != 0 ? v26 : v26 / 0x10000); // 0x40376c
    int32_t v28 = ((v25 & 0x8080) != 0 ? v24 : v22 + 6) - (-1 - v27 < v27 ? 4 : 3) - v5; // 0x403771
    int32_t size = v28 + 284; // 0x403773
    v2 = (char *)size;
    int32_t * mem = malloc(size); // 0x40377c
    int32_t result = (int32_t)mem; // 0x40377c
    if (mem == NULL) {
        // 0x40380f
        *_errno() = 12;
        // 0x4037d1
        return result;
    }
    int32_t v29 = result + 280; // 0x40378b
    v2 = (char *)v29;
    memcpy((int32_t *)v29, &v4, v28 + 1);
    int32_t v30 = function_403500(); // 0x4037a8
    *(int32_t *)(result + 272) = v30;
    int32_t result2; // 0x403680
    if (v30 == -1) {
        // 0x40382b
        v2 = (char *)mem;
        free(mem);
        result2 = 0;
    } else {
        // 0x4037b8
        *(int32_t *)(result + 276) = 0;
        *mem = 0;
        *(int16_t *)(result + 4) = 272;
        result2 = result;
    }
    // 0x4037d1
    return result2;
}

// Address range: 0x403840 - 0x403886
int32_t function_403840(int32_t result) {
    if (result == 0) {
        // 0x403877
        *_errno() = 9;
        // 0x403872
        return 0;
    }
    int32_t * v1 = (int32_t *)(result + 276); // 0x40384c
    uint32_t v2 = *v1; // 0x40384c
    *v1 = v2 + 1;
    if (v2 >= 1) {
        // 0x40385f
        if (function_4035d0() == 0) {
            // 0x403872
            return 0;
        }
    }
    // 0x403872
    return result;
}

// Address range: 0x403890 - 0x4038d2
int32_t function_403890(int32_t a1) {
    if (a1 == 0 || !FindClose((int32_t *)*(int32_t *)(a1 + 272))) {
        // 0x4038c0
        *_errno() = 9;
        // 0x4038bb
        return -1;
    }
    // 0x4038b1
    free((int32_t *)a1);
    // 0x4038bb
    return 0;
}

// Address range: 0x4038e0 - 0x403938
int32_t function_4038e0(int32_t a1) {
    int32_t * v1; // 0x403901
    if (a1 == 0) {
        // 0x403901
        v1 = _errno();
        *v1 = 9;
        // 0x40390c
        return (int32_t)v1;
    }
    int32_t * hFindFile = (int32_t *)(a1 + 272); // 0x4038ec
    if (!FindClose((int32_t *)*hFindFile)) {
        // 0x403901
        v1 = _errno();
        *v1 = 9;
        // 0x40390c
        return (int32_t)v1;
    }
    int32_t result = function_403500(); // 0x403919
    *hFindFile = result;
    if (result == -1) {
        // 0x40390c
        return -1;
    }
    // 0x403929
    *(int32_t *)(a1 + 276) = 0;
    return result;
}

// Address range: 0x403940 - 0x403967
int32_t function_403940(int32_t a1) {
    int32_t result; // 0x403940
    if (a1 == 0) {
        // 0x403955
        *_errno() = 9;
        result = -1;
    } else {
        // 0x40394b
        result = *(int32_t *)(a1 + 276);
    }
    // 0x403951
    return result;
}

// Address range: 0x403970 - 0x4039e1
int32_t function_403970(int32_t a1, uint32_t a2) {
    if ((int32_t)a2 < 0) {
        int32_t * v1 = _errno(); // 0x4039d0
        *v1 = 22;
        return (int32_t)v1;
    }
    int32_t result = function_4038e0(a1); // 0x403984
    if (a2 == 0 || *(int32_t *)(a1 + 272) == -1) {
        // 0x4039c4
        return result;
    }
    int32_t * v2 = (int32_t *)(a1 + 276); // 0x4039b1
    int32_t v3 = *v2 + 1; // 0x4039b7
    *v2 = v3;
    int32_t result2 = v3; // 0x4039c2
    while (v3 < a2) {
        // 0x4039a0
        result2 = 0;
        if (function_4035d0() == 0) {
            // break -> 0x4039c4
            break;
        }
        v3 = *v2 + 1;
        *v2 = v3;
        result2 = v3;
    }
    // 0x4039c4
    return result2;
}

// Address range: 0x4039f0 - 0x4039f6
int32_t function_4039f0(char * s, int16_t * pwcs, int32_t n) {
    // 0x4039f0
    return wcstombs(s, pwcs, n);
}

// Address range: 0x4039f8 - 0x4039fe
int32_t function_4039f8(struct _IO_FILE * s, char * format, int32_t arg) {
    // 0x4039f8
    return vfprintf(s, format, arg);
}

// Address range: 0x403a00 - 0x403a06
int32_t function_403a00(int32_t c) {
    // 0x403a00
    return tolower(c);
}

// Address range: 0x403a08 - 0x403a0e
int32_t function_403a08(char * s) {
    // 0x403a08
    return strlen(s);
}

// Address range: 0x403a10 - 0x403a16
int32_t function_403a10(char * s1, char * s2) {
    // 0x403a10
    return strcoll(s1, s2);
}

// Address range: 0x403a18 - 0x403a1e
void (*function_403a18(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x403a18
    return signal(sig, handler);
}

// Address range: 0x403a20 - 0x403a26
char * function_403a20(int32_t category, char * locale) {
    // 0x403a20
    return setlocale(category, locale);
}

// Address range: 0x403a28 - 0x403a2e
int32_t * function_403a28(int32_t * ptr, int32_t size) {
    // 0x403a28
    return realloc(ptr, size);
}

// Address range: 0x403a30 - 0x403a36
int32_t * function_403a30(int32_t * dest, int32_t * src, int32_t n) {
    // 0x403a30
    return memcpy(dest, src, n);
}

// Address range: 0x403a38 - 0x403a3e
int32_t function_403a38(int16_t * pwcs, char * s, int32_t n) {
    // 0x403a38
    return mbstowcs(pwcs, s, n);
}

// Address range: 0x403a40 - 0x403a46
int32_t * function_403a40(int32_t size) {
    // 0x403a40
    return malloc(size);
}

// Address range: 0x403a48 - 0x403a4e
int32_t function_403a48(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x403a48
    return fwrite(ptr, size, n, s);
}

// Address range: 0x403a50 - 0x403a56
void function_403a50(int32_t * ptr) {
    // 0x403a50
    free(ptr);
}

// Address range: 0x403a58 - 0x403a5e
int32_t * function_403a58(int32_t nmemb, int32_t size) {
    // 0x403a58
    return calloc(nmemb, size);
}

// Address range: 0x403a60 - 0x403a66
void function_403a60(void) {
    // 0x403a60
    abort();
}

// Address range: 0x403a68 - 0x403a6e
int32_t function_403a68(int32_t FileHandle, int32_t Mode) {
    // 0x403a68
    return _setmode(FileHandle, Mode);
}

// Address range: 0x403a70 - 0x403a76
int32_t function_403a70(int32_t C, int32_t Type) {
    // 0x403a70
    return _isctype(C, Type);
}

// Address range: 0x403a78 - 0x403a7e
char * function_403a78(char * Buffer, char * Path, int32_t BufferCount) {
    // 0x403a78
    return _fullpath(Buffer, Path, BufferCount);
}

// Address range: 0x403a80 - 0x403a86
int32_t * function_403a80(void) {
    // 0x403a80
    return _errno();
}

// Address range: 0x403a88 - 0x403a8e
void function_403a88(void) {
    // 0x403a88
    _cexit();
}

// Address range: 0x403a90 - 0x403a96
int32_t * function_403a90(void) {
    // 0x403a90
    return __p__fmode();
}

// Address range: 0x403a98 - 0x403a9e
char *** function_403a98(void) {
    // 0x403a98
    return __p__environ();
}

// Address range: 0x403aa0 - 0x403aa6
int32_t function_403aa0(int32_t * Argc, char *** Argv, char *** Env, int32_t DoWildCard, int32_t * StartInfo) {
    // 0x403aa0
    return __getmainargs(Argc, Argv, Env, DoWildCard, StartInfo);
}

// Address range: 0x403aa8 - 0x403aae
bool function_403aa8(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped) {
    // 0x403aa8
    return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

// Address range: 0x403ab0 - 0x403ab6
int32_t function_403ab0(int32_t * lpAddress, struct _MEMORY_BASIC_INFORMATION * lpBuffer, int32_t dwLength) {
    // 0x403ab0
    return VirtualQuery(lpAddress, lpBuffer, dwLength);
}

// Address range: 0x403ab8 - 0x403abe
bool function_403ab8(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect) {
    // 0x403ab8
    return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

// Address range: 0x403ac0 - 0x403ac6
int32_t * function_403ac0(int32_t dwTlsIndex) {
    // 0x403ac0
    return TlsGetValue(dwTlsIndex);
}

// Address range: 0x403ac8 - 0x403ace
int32_t (*function_403ac8(int32_t (*lpTopLevelExceptionFilter)(struct _EXCEPTION_POINTERS *)))(struct _EXCEPTION_POINTERS *) {
    // 0x403ac8
    return SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
}

// Address range: 0x403ad0 - 0x403ad6
int32_t * function_403ad0(char * lpLibFileName) {
    // 0x403ad0
    return LoadLibraryA(lpLibFileName);
}

// Address range: 0x403ad8 - 0x403ade
void function_403ad8(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x403ad8
    LeaveCriticalSection(lpCriticalSection);
}

// Address range: 0x403ae0 - 0x403ae6
void function_403ae0(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x403ae0
    InitializeCriticalSection(lpCriticalSection);
}

// Address range: 0x403ae8 - 0x403aee
int32_t (*function_403ae8(int32_t * hModule, char * lpProcName))() {
    // 0x403ae8
    return GetProcAddress(hModule, lpProcName);
}

// Address range: 0x403af0 - 0x403af6
int32_t * function_403af0(char * lpModuleName) {
    // 0x403af0
    return GetModuleHandleA(lpModuleName);
}

// Address range: 0x403af8 - 0x403afe
int32_t function_403af8(void) {
    // 0x403af8
    return GetLastError();
}

// Address range: 0x403b00 - 0x403b06
char * function_403b00(void) {
    // 0x403b00
    return GetCommandLineA();
}

// Address range: 0x403b08 - 0x403b0e
bool function_403b08(int32_t * hLibModule) {
    // 0x403b08
    return FreeLibrary(hLibModule);
}

// Address range: 0x403b10 - 0x403b16
bool function_403b10(int32_t * hFindFile, struct _WIN32_FIND_DATAA * lpFindFileData) {
    // 0x403b10
    return FindNextFileA(hFindFile, lpFindFileData);
}

// Address range: 0x403b18 - 0x403b1e
int32_t * function_403b18(char * lpFileName, struct _WIN32_FIND_DATAA * lpFindFileData) {
    // 0x403b18
    return FindFirstFileA(lpFileName, lpFindFileData);
}

// Address range: 0x403b20 - 0x403b26
bool function_403b20(int32_t * hFindFile) {
    // 0x403b20
    return FindClose(hFindFile);
}

// Address range: 0x403b28 - 0x403b2e
void function_403b28(int32_t uExitCode) {
    // 0x403b28
    ExitProcess(uExitCode);
}

// Address range: 0x403b30 - 0x403b36
void function_403b30(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x403b30
    EnterCriticalSection(lpCriticalSection);
}

// Address range: 0x403b38 - 0x403b3e
void function_403b38(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x403b38
    DeleteCriticalSection(lpCriticalSection);
}

// Address range: 0x403b40 - 0x403b46
int32_t * function_403b40(int16_t * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile) {
    // 0x403b40
    return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// Address range: 0x403b48 - 0x403b4e
bool function_403b48(int32_t * hObject) {
    // 0x403b48
    return CloseHandle(hObject);
}

// Address range: 0x403b50 - 0x403b56
int32_t function_403b50(char * String1, char * String2) {
    // 0x403b50
    return _stricoll(String1, String2);
}

// Address range: 0x403b58 - 0x403b5e
char * function_403b58(char * Source) {
    // 0x403b58
    return _strdup(Source);
}

// Address range: 0x403b60 - 0x403c17
int32_t function_403b60(int32_t a1) {
    // 0x403b60
    int32_t v1; // 0x403b60
    int32_t v2 = &v1; // bp-20, 0x403b74
    int32_t v3 = (int32_t)&v2 - function_401fe0(); // 0x403b7f
    function_401990();
    int32_t v4; // bp-8224, 0x403b60
    __asm_rep_movsd_memcpy((char *)&v4, (char *)&g3, 2048);
    *(int32_t *)(v3 + 24) = 0;
    *(int32_t *)(v3 + 20) = 0;
    *(int32_t *)(v3 + 16) = 3;
    *(int32_t *)(v3 + 12) = 0;
    *(int32_t *)(v3 + 8) = 3;
    *(int32_t *)(v3 + 4) = 0x10000000;
    *(int32_t *)v3 = (int32_t)L"\\\\.\\PhysicalDrive0";
    int32_t * v5 = CreateFileW((int16_t *)&g27, (int32_t)&g27, (int32_t)&g27, (struct _SECURITY_ATTRIBUTES *)&g27, (int32_t)&g27, (int32_t)&g27, &g27); // 0x403bca
    int32_t v6 = (int32_t)v5; // 0x403bca
    *(int32_t *)(v3 - 28) = v6;
    *(int32_t *)(v3 - 12) = 0;
    *(int32_t *)(v3 - 16) = 0;
    *(int32_t *)(v3 - 20) = 512;
    *(int32_t *)(v3 - 24) = (int32_t)&v4;
    WriteFile(&g27, &g27, (int32_t)&g27, &g27, (struct _OVERLAPPED *)&g27);
    *(int32_t *)(v3 - 48) = v6;
    *(int32_t *)(v3 - 52) = (int32_t)CloseHandle(&g27);
    return 0;
}

// Address range: 0x403c20 - 0x403c29
int32_t function_403c20(void) {
    // 0x403c20
    return function_401340();
}

// --------------- Dynamically Linked Functions ---------------

// int __getmainargs(int * Argc, char *** Argv, char *** Env, int DoWildCard, _startupinfo * StartInfo);
// char *** __cdecl __p__environ(void);
// int * __cdecl __p__fmode(void);
// void __set_app_type(int at);
// void __cdecl _cexit(void);
// int * __cdecl _errno(void);
// void __cdecl _fpreset(void);
// char * __cdecl _fullpath(char * Buffer, _In_z_ char const * Path, _In_ size_t BufferCount);
// int __cdecl _isctype(_In_ int C, _In_ int Type);
// _onexit_t _onexit(_onexit_t Function);
// int __cdecl _setmode(_In_ int FileHandle, _In_ int Mode);
// char * __cdecl _strdup(char const * Source);
// int __cdecl _stricoll(_In_z_ char const * String1, _In_z_ char const * String2);
// void abort(void);
// int atexit(void(* func)(void));
// void * calloc(size_t nmemb, size_t size);
// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateFileW(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileA(_In_ LPCSTR lpFileName, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// BOOL FindNextFileA(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// void free(void * ptr);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// LPSTR GetCommandLineA(VOID);
// DWORD GetLastError(VOID);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// HMODULE LoadLibraryA(_In_ LPCSTR lpLibFileName);
// void * malloc(size_t size);
// size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * realloc(void * ptr, size_t size);
// char * setlocale(int category, const char * locale);
// LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int strcoll(const char * s1, const char * s2);
// size_t strlen(const char * s);
// LPVOID TlsGetValue(_In_ DWORD dwTlsIndex);
// int tolower(int c);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);
// BOOL VirtualProtect(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect);
// SIZE_T VirtualQuery(_In_opt_ LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, _In_ SIZE_T dwLength);
// size_t wcstombs(char * restrict s, const wchar_t * restrict pwcs, size_t n);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft
// Detected functions: 91
